<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"APISocket.js.html":{"id":"APISocket.js.html","title":"Source: APISocket.js","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser Source: APISocket.js import axios from 'axios'; import io from &quot;socket.io-client&quot; import { User } from &quot;./User&quot;; import { Team } from &quot;./Team&quot;; import { Logger } from &quot;./Logger&quot;; import { Guest } from &quot;./Guest&quot;; import { removeTrailingSlash } from &quot;../Skrumble&quot;; /** * @class * @classdesc * Allows connection to the Skrumble API through a persistent socket connection. Many other classes like {@link User}, {@link Chat}, and {@link Department} rely on APISocket to make requests. * * @example * something */ export class APISocket { constructor(opts) { /** * @prop socket * @type {Object} * @summary * The socket used to make requests. */ this.socket = false; /** * @readonly * @prop client_id * @type {String} * @summary * The Client ID of the application. This is read-only, set using {@link config} */ this.client_id = &quot;&quot;; /** * @readonly * @prop client_secret * @type {String} * @summary * The Client Secret of the application. This is read-only, set using {@link config} */ this.client_secret = &quot;&quot;; /** * @readonly * @prop hostname * @type {String} * @summary * The hostname for future API reqeust, set using {@link config} */ this.hostname = &quot;&quot;; /** * @readonly * @prop api_url * @type {String} * */ this.api_url = &quot;https://app.skrumble.com&quot;; /** * @readonly * @prop auth_token * @type {String} * @summary * The logged-in user's bearer token, this will automatically be appended to all future requests. */ this.auth_token = &quot;&quot;; /** * @readonly * @prop refresh_token * @type {String} * @summary * The logged-in user's refresh token, this will automatically be used to refresh the {@link APISocket#auth_token} * when the token has expired or requests begin failing with an HTTP code of 403 */ this.refresh_token = &quot;&quot;; /** * @readonly * @prop current_user * @type {User} * @summary * After logging in and auth/refresh tokens are set properly, this will be the currently logged-in user * for this socket connection. */ this.current_user = false; } /** * @summary * Authenticate a user and start listening for events over a persistent socket connection. * * @description * Logs-in a user with the provided email and password. When the returned promise * is resolved, it will return the authenticated user. Also connects user to the socket by default. * * @memberof APISocket * @param {Object} opts The options for this request * @param {String} opts.email Email address of the account to log-in * @param {String} opts.password Password of the account to log-in * @param {Boolean} [opts.connect_socket=true] After a successful login, should the user's socket * connection be initiated automatically. If this is disabled the socket connection must be created * manually using {@link connectSocket} * * @static * * @example * Skrumble.APISocket.login({ * email: &quot;myuser@gmail.com&quot;, * password: &quot;123456&quot; * }) * .then((user) =&gt; { * console.log(user, &quot;is now logged in!&quot;); * }) * .catch((err) =&gt; { * console.error(&quot;Couldn't log-in!&quot;, err); * }) * */ static async login(opts) { let fields_missing = []; var options = Object.assign({}, { email: false, password: false, connect_socket: true }, opts); if (!options.email) fields_missing.push(&quot;email&quot;); if (!options.password) fields_missing.push(&quot;password&quot;); if (fields_missing.length &gt; 0) { throw new Error(&quot;Login error, fields missing:&quot;, fields_missing.join(', ')) } let auth_url = `https://${this.auth_hostname}/v1/login-user` // Get the user's token and refresh token let auth_result = await axios({ method: &quot;post&quot;, url: auth_url, data: { grant_type: &quot;password&quot;, username: options.email, password: options.password, client_id: this.client_id, client_secret: this.client_secret } }); if (Math.floor(auth_result.status/100) !== 2) { throw new Error(err); } else { if (auth_result.data.access_token) this.access_token = auth_result.data.access_token; if (auth_result.data.refresh_token) this.refresh_token = auth_result.data.refresh_token; if (options.connect_socket &amp;&amp; this.access_token &amp;&amp; this.refresh_token) { var SocketRegistered = await this.connectSocket(); this.current_user = new User(await this.loadCurUser()); } else { throw new Error(&quot;Socket registration failed&quot;, auth_result); } } return this.current_user; } /** * @summary * Authenticates a guest and start listening for events over a persistent socket connection. * * @description * Logs-in a guest user, which are given access only to one group conversation. When the returned * promise is resolved, it will return the authenticated guest user. Also connects to the socket * by default. * * @memberof APISocket * @param {Object} opts The options for this request * @param {String} opts.first_name The first name of the guest * @param {String} opts.last_name The last name of the guest * @param {String} opts.email The email address of the guest * @param {String} opts.pin The {@link Chat#pin PIN} of the chat the guest is joining. * @param {String} opts.chat The {@link Chat#id ID} of the chat the guest is joining. * @param {String} opts.team The {@link Team#slug slug} of the team that owns the chat * the guest is joining. * */ static async loginGuest(opts) { console.log(&quot;Logging guest in with options&quot;, opts); let fields_missing = []; let options = Object.assign({}, { first_name: false, last_name: false, email: false, pin: false, chat: false, team: false, }, opts); if (!options.email) fields_missing.push('email'); if (!options.first_name) fields_missing.push('first_name'); if (!options.last_name) fields_missing.push('last_name'); if (!options.pin) fields_missing.push('pin'); if (!options.chat) fields_missing.push('chat'); if (!options.team) fields_missing.push('team'); if (fields_missing.length &gt; 0) { throw new Error(&quot;Guest login error, fields missing:&quot;, fields_missing.join(', ')) } let auth_url = `${this.api_url}guest/join`; let auth_result = await axios({ method: 'POST', url: auth_url, data: options }) console.log(&quot;Guest user result&quot;, auth_result); if (Math.floor(auth_result.status/100) !== 2) { console.log(auth_result); // throw new Error(err); } else { if (auth_result.data.access_token) this.access_token = auth_result.data.access_token; if (auth_result.data.refresh_token) this.refresh_token = auth_result.data.refresh_token; if (this.access_token &amp;&amp; this.refresh_token) { var SocketRegistered = await this.connectSocket(); this.current_user = new Guest(await this.loadCurUser()); console.log(&quot;Guest user set&quot;, this.current_user); } else { throw new Error(&quot;Socket registration failed&quot;, auth_result); } } return this.current_user; } /** * Load the current user based on their access token * * @memberof APISocket * @static */ static async loadCurUser() { var user_result = await APISocket.get(`user/me?populate=teams&amp;extension=true`) // User is on one team: normalize values that are stored on the TeamUser object if (user_result.teams.length === 1) { // Properties defined on the TeamUser that need to be normalized back into actual user properties var team_user = await APISocket.get(`team/${user_result.teams[0].id}/users/${user_result.id}`) for (let [key, value] of Object.entries(team_user)) { user_result[key] = value; } } // Load all teams by ID user_result.teams.map(async (team_props) =&gt; { var team = await Team.get({ id: team_props.id }); user_result.teams.push(team); }) // Rename/remap fields user_result.extension_secret = (&quot; &quot; + user_result.extensionSecret).slice(1); delete user_result.extensionSecret; return user_result; } /** * @static * @async * @summary * Initiates the socket connection. * * @description * This connects a user to the socket and registers them for future changes. After the call to `login` completes, default behaviour will be to call this automatically. * */ static connectSocket() { return new Promise((resolve, reject) =&gt; { const socket = io( `${this.api_url}`, { path: '/socket.io/', transports: ['websocket'], query: { '__sails_io_sdk_version': '1.1.13', '__sk_js_sdk_version': '0.1.1' } } ); this.socket = socket; socket.on('connect', async () =&gt; { try { let register_res = await APISocket.post(`socket/register`) resolve(true); } catch(err) { reject(err); } }); socket.on('connect_error', onConnectError) socket.on('connect_timeout', onConnectError) socket.on('connect_timeout', onConnectError) const onConnectError = () =&gt; { console.log(&quot;connection error&quot;); reject(false); } }); } /** * @static * @summary * Logs out the current user by forcefully closing the socket and resetting APISocket.current_user * */ static logout() { this.socket = false; this.current_user = false; } /** * @static * @async * @summary * Sends a GET request to the API socket. * * @param {String} url - Url to be passed to socket.io.get() * @param {Object} data - Data to be sent with the request * * @returns {Promise} - A promise object that either is resolved * with success for sucessful (`2xx`) responses with the body of the response * as the first argument. If the request fails (`!= 2xx`), the promise will * be rejected with the body of the response as the first argument, and a * JSON Websocket Response object as the second argument. */ static get(url, data, append_url = true) { return APISocket.request('get', url, data, append_url); } /** * @static * @async * @summary * Sends a POST request * * @param {String} url - Url to be passed to socket.io.get() * @param {Object} options - Options object to be passed to socket.io.get() * @returns {Promise} - A promise object that either is resolved * with success for sucessful (`2xx`) responses with the body of the response * as the first argument. If the request fails (`!= 2xx`), the promise will * be rejected with the body of the response as the first argument. */ static post(url, data, append_url = true) { return APISocket.request('post', url, data, append_url); } /** * @static * @async * @summary * Sends a POST request * * @param {String} url - Url to be passed to socket.io.get() * @param {Object} options - Options object to be passed to socket.io.get() * @returns {Promise} - A promise object that either is resolved * with success for sucessful (`2xx`) responses with the body of the response * as the first argument. If the request fails (`!= 2xx`), the promise will * be rejected with the body of the response as the first argument. */ static patch(url, data, append_url = true) { return APISocket.request('patch', url, data, append_url); } /** * @static * @async * @summary * Sends a DELETE request * * @param {String} url - Url to be passed to socket.io.get() * @param {Object} options - Options object to be passed to socket.io.get() * @returns {Promise} - A promise object that either is resolved * with success for sucessful (`2xx`) responses with the body of the response * as the first argument. If the request fails (`!= 2xx`), the promise will * be rejected with the body of the response as the first argument. */ static delete(url, data, append_url = true) { return APISocket.request('delete', url, data, append_url); } /** * @static * @async * @summary * Sends a request with a given HTTP method. Shorthand versions are available * as APISocket.get(), post(), patch(), and delete() * * @param {String} method - HTTP Method to be used in the request * @param {String} url - Url to be passed to socket.io.get() * @param {Object} options - Options object to be passed to socket.io.get() * @returns {Promise} - A promise object that either is resolved * with success for sucessful (`2xx`) responses with the body of the response * as the first argument. If the request fails (`!= 2xx`), the promise will * be rejected with the body of the response as the first argument. */ static request(method, url, data, append_url = true) { return new Promise((resolve, reject) =&gt; { this.socket.emit(method, { url: (append_url) ? `${APISocket.api_url}/v3/${url}` : url, headers: { &quot;Authorization&quot;: `Bearer ${this.access_token}` }, method, data, }, async (res) =&gt; { if (Math.floor(res.statusCode/100) === 2) { resolve(res.body, res); } else { throw new Error(`${res.statusCode} error: ${res.body}`); reject(res.body, res); } } ) }) } /** * @static * @summary * Listens for socket messages coming into the API socket. * * @description * The Skrumble API will emit the following types of events: * * | Event | Description | * | --- | --- | * | chat | This is the event about a chat, including new messages, changes to the participant list, or name | * | user | Event is about a user that has changed: `state`, `status`, `*_name`, `avatar`, etc | * | teamuser | Event is about a user that has changed: `state`, `status`, `*_name`, `avatar`, etc | * | team | Changes to the team information | * | conference | Changes to a group call's status | * * Because this is a static method, the events above will fire for any activity of that type. For example, `chat` will be triggered on * changes to all chats on the current team. To monitor an individual chat, use {@link Chat.on} * * @param {String} evt The event type to listen for * @param {Function} callback Callback to fire when the event occurs */ static on(evt, callback) { if (this.socket) { this.socket.on(evt, callback); } else { Logger.warn(&quot;Socket not connected&quot;); } } /** * @static * @summary * Unbinds a listener bound using {@link APISocket.on} * * @param {String} evt The event type to unbind * @param {function} callback Callback to unbind from this event */ static off(evt, callback) { if (this.socket) { this.socket.off(evt, callback); } else { Logger.warn(&quot;Socket not connected&quot;); } } /** * @static * @summary * Configures the API socket for use, including the URLs and client tokens * * @param {Object} opts - Configuration options * @param {String} opts.client_id - Client ID of this application * @param {String} opts.client_secret - Client secret of this application * @param {String} opts.api_hostnae - Hostname for API requests, don't include protocol or port number * @param {String} opts.auth_hostname - Hostname for Auth requests */ static async config(opts) { var options = Object.assign({}, { client_id: false, client_secret: false, api_hostname: &quot;app.skrumble.com&quot;, auth_hostname: &quot;app.skrumble.com&quot; }, opts); if (options.client_id) { this.client_id = options.client_id; } else { throw new Error(&quot;client_id is required&quot;); } if (options.client_secret) { this.client_secret = options.client_secret; } else { throw new Error(&quot;client_id is required&quot;); } if (typeof options.api_hostname == &quot;string&quot; &amp;&amp; !options.api_hostname.match(/^\\s*$/gm)) { this.hostname = removeTrailingSlash(options.api_hostname); this.api_url = `https://${this.hostname}`; } if (typeof options.auth_hostname == &quot;string&quot; &amp;&amp; !options.auth_hostname.match(/^\\s*$/gm)) { this.auth_hostname = removeTrailingSlash(options.auth_hostname); } } } × Search results Close "},"Chat.js.html":{"id":"Chat.js.html","title":"Source: Chat.js","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser Source: Chat.js import { APISocket } from &quot;./APISocket&quot;; import { Logger } from &quot;./Logger&quot;; import { User } from &quot;./User&quot;; import { ChatMessage } from &quot;./ChatMessage&quot;; /** * @class Chat * @classdesc * A chat comes in two major types (see the `type` property): * * * **Private** chats between exactly two {@link User users} * * **Group** chats, which can contain a mixture of users and {@link Guest guests}. Groups must contain at least one user, but have no upper-limit. Groups also have the property `roomNumber` and `pin`, which allows outside callers to call the chat directly. */ export class Chat { _mimeTypes = { 'ai' : 'application/postscript', 'au' : 'audio/basic', 'avi' : 'video/x-msvideo', 'bat' : 'text/plain', 'bmp' : 'image/x-ms-bmp', 'c' : 'text/plain', 'css' : 'text/css', 'doc' : 'application/msword', 'dot' : 'application/msword', 'eps' : 'application/postscript', 'gif' : 'image/gif', 'h' : 'text/plain', 'htm' : 'text/html', 'html' : 'text/html', 'jpeg' : 'image/jpeg', 'js' : 'application/x-javascript', 'json' : 'application/json', 'mov' : 'video/quicktime', 'movie' : 'video/x-sgi-movie', 'mp2' : 'audio/mpeg', 'mp3' : 'audio/mpeg', 'mp4' : 'video/mp4', 'mpeg' : 'video/mpeg', 'numbers': 'application/octet-stream', 'pdf' : 'application/pdf', 'png' : 'image/png', 'pot' : 'application/vnd.ms-powerpoint', 'ppa' : 'application/vnd.ms-powerpoint', 'ppm' : 'image/x-portable-pixmap', 'pps' : 'application/vnd.ms-powerpoint', 'ppt' : 'application/vnd.ms-powerpoint', 'pptx' : 'application/vnd.ms-powerpoint', 'ps' : 'application/postscript', 'pwz' : 'application/vnd.ms-powerpoint', 'py' : 'text/x-python', 'pyc' : 'application/x-python-code', 'pyo' : 'application/x-python-code', 'qt' : 'video/quicktime', 'tif' : 'image/tiff', 'txt' : 'text/plain', 'vcf' : 'text/x-vcard', 'wav' : 'audio/x-wav', 'wiz' : 'application/msword', 'wsdl' : 'application/xml', 'xbm' : 'image/x-xbitmap', 'xlb' : 'application/vnd.ms-excel', 'xls' : 'application/vnd.ms-excel', 'xlsx' : 'application/vnd.ms-excel', 'xml' : 'text/xml', 'xpdl' : 'application/xml', 'xpm' : 'image/x-xpixmap', 'xsl' : 'application/xml', 'zip' : 'application/zip' } _listeners = { &quot;updated&quot;: [], &quot;message&quot;: [] } /** * @prop id * @type {String} * @summary * The ID of the chat. */ id = &quot;&quot;; /** * @prop type * @type {String} * @summary * The type of the chat, options are `private` or `group`. */ type = &quot;&quot;; /** * @prop name * @type {String} * @summary * The name of the chat. For private chats, this will be name of the other user. * For a group chat, this will be a separate, unique name. */ name = &quot;&quot;; /** * @prop purpose * @type {String} * @summary * The intended purpose of the chat. Only present on groups, this will be ignored * for private chats */ purpose = &quot;&quot;; /** * @prop avatar * @type {String} * @summary * The avatar for the chat. Only present on rooms */ avatar = &quot;&quot;; /** * @prop roomNumber * @type {Number} * @summary * Room number for calling to this chat via PSTN bridge. */ roomNumber = null; /** * @prop unread * @type {Number} * @summary * Number of unread messages in this chat from the current user's perspective. */ unread = 0; /** * @prop locked * @type {Boolean} * @summary * Locked groups will block guest access, and disconnect any guests. Unlocked groups allow guests * to access the chat using the {@linkcode Chat#url} property */ locked /** * @prop pin * @type {Number} * @summary * PIN for calling to this chat via PSTN bridge, or for guest logins. */ pin = null; /** * @prop links * @type {Object[]} * @summary * List of URLs referenced in the messages of the chat. */ links = []; /** * @prop files * @type {Object[]} * @summary * List of files sent in the chat. */ files = []; /** * @prop url * @type {String} * @summary * The URL that guests can access this chat at. Only available on group chats. */ url = &quot;&quot;; /** * @prop messages * @type {ChatMessage[]} * @summary * The list of {@link ChatMessages} in this chat, in chronological order. */ messages = []; /** * @prop users * @type {User[]} * @summary * The list of {@link User Users} in this chat. */ users = []; /** * @prop created_at * @type {String} * @summary * ISO-8601 timestamp of when this chat was created. */ created_at = false; /** * @prop updated_at * @type {String} * @summary * ISO-8601 timestmap of when this chat was last modified. */ updated_at = false; /** * @prop last_seen * @type {String} * @summary * ISO-8601 timestamp of when this chat was last read, from the perspective * of the currently logged-in user. */ last_seen = false; /** * @prop last_message_time * @type {String} * @summary * ISO-8601 timestamp of when this chat received it's last message */ last_message_time = false; /** * @prop do_not_disturb * @type {Boolean} * @summary * Has this chat been set to silence notifications, from the perspective * of the currently logged-in user. */ do_not_disturb = false; /** * @prop favourite * @type {Boolean} * @summary * Has this chat been marked as a favourite, from the perspective of the * currently logged-in user. */ favourite = false; /** * @prop team * @type {Team} * @summary * ID of the Team that this chat belongs to. Needed for the `save()` method. * TODO: find a more elegant way to save this */ team = false; constructor(opts) { // Assign in passed values for (let [key, value] of Object.entries(opts)) { if (this.hasOwnProperty(key)) { // Stop using the word &quot;room&quot; if (key == &quot;type&quot; &amp;&amp; value == &quot;room&quot;) value = &quot;group&quot;; // Turn the users list into real users if (key == &quot;users&quot;) { value = value.map((user) =&gt; { user = new User(user) return user; }); } this[key] = value; } else { // Logger.info(&quot;Key not found&quot;, key, value); } } if (this.id) { APISocket.on('chat', (chat_evt) =&gt; { let updated_evt = false; // Should this event trigger `updated` event let message_evt = false; // Should this event trigger `message` event switch (chat_evt.verb) { case &quot;addedTo&quot;: if (chat_evt.attribute == &quot;messages&quot;) { switch (chat_evt.added.type) { case &quot;chat_renamed&quot;: this.name = chat_evt.added.body.new; updated_evt = true; break; case &quot;chat_locked&quot;: this.locked = !!chat.evt.added.body; updated_evt = true; break; case &quot;chat_purpose&quot;: this.purpose = chat_evt.added.body.new; updated_evt = true; break; } // If this wasn't an update, it was message, so notify listeners if (!updated_evt) message_evt = true; } break; case &quot;updated&quot;: if (typeof chat_evt.data.unread !== &quot;undefined&quot;) { this.unread = chat_evt.data.unread; updated_evt = true } else if (typeof chat_evt.data.last_message_time !== &quot;undefined&quot;) { this.last_message_time = chat_evt.data.last_message_time; updated_evt = true } else if (typeof chat_evt.data.updatedAt !== &quot;undefined&quot;) { this.updated_at = chat_evt.data.updatedAt; updated_evt = true } break; } if (updated_evt) { this._listeners.updated.map((callback) =&gt; { callback.call(this, chat_evt, this); }); } else if (message_evt) { let message = new ChatMessage(chat_evt.added) this._listeners.message.map((callback) =&gt; { this.messages.unshift(message) callback.call(this, chat_evt, this, message) }); } }); } } _onSocketMessage() { } // Try and get file extenion from the filename or mimetype _getFileExtension(fileObj) { let extension = /(?:\\.([^.]+))?$/.exec(fileObj.filename)[1]; // Try and get proper file extenion based on mimetype for (let ext in this._mimeTypes) { if(this._mimeTypes[ext] == fileObj.mimetype) extension = ext; } if (fileObj.mimetype == 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') { extension = 'xlsx'; } return extension; } /** * @static * @summary * Gets all chats that this user has access to, based on the pagination options `limit`, and `skip` * * @param {Object} opts The options for this requiest * @param {Number} [opts.limit=1000] Maximum number of chats to load * @param {Number} [opts.skip=0] Chat number to start from */ static async getAll(opts) { let options = Object.assign({}, { limit: 1000, skip: 0 }, opts); let chats = []; let chats_raw = await APISocket.get(`chat?populate=users&amp;limit=${options.limit}&amp;skip=${options.skip}`); chats_raw.map((chat_info) =&gt; { let chat = new Chat(chat_info) // Turn user list into real user obects if (chat_info.users &amp;&amp; chat_info.users.legnth &gt; 0) { chat.users = chat_info.users.map((chat_userinfo) =&gt; new User(chat_userinfo)); } chats.push(chat); }); return chats; } /** * @summary * Gets a specific chat by ID. Loads chat messages by default, but for smaller responses this can be disabled * with `opts.load_messages = false` * * @param {Object} opts The options for this request * @param {String} opts.id The ID of the chat to load * @param {Boolean} [opts.load_messages=true] `true` to load the chat message list, or `false` to disable * @param {Number} [opts.message_limit=50] Maximum number of messages to load * @param {Number} [opts.message_skip=0] Message number to start from */ static async get(opts) { let options = Object.assign({}, { id: false, load_messages: true, message_limit: 50, message_skip: 0 }, opts); if (!options.id) Logger.error(&quot;Chat.get requires an id&quot;); let querystring = &quot;populate=users&amp;sort=updatedAt+DESC&amp;limit=1000&amp;skip=0&quot; let chat_info = await APISocket.get(`chat/${options.id}?${querystring}`) if (options.load_messages === true) { let messages = await APISocket.get(`chat/${options.id}/messages?populate=file&amp;populate=user_mentions&amp;limit=${options.message_limit}&amp;skip=${options.message_skip}`); messages = messages.sort(function(a, b) { if (new Date(a) &lt; new Date(b)) { return 1; } else if (new Date(a) &gt; new Date(b)) { return -1; } else if (new Date(a) == new Date(b)) { return 0; } }); messages.map((message_data) =&gt; { chat_info.messages.push(new ChatMessage(message_data)); }) } return new Chat(chat_info); } /** * @static * @async * @summary * Saves a chat object by attempting to commit any dirty fields to the appropriate API endpoints. If the chat * has an `id` and `created_at` date, then it will attempt to save the information. If */ async save(opts) { let options = Object.assign({}, { }, opts); if (this.created_at &amp;&amp; this.id) { console.log(&quot;Existing chat&quot;); // PATCH /chat/:chat_id // ONLY name, purpose and locked } else { console.log(&quot;No created_at, creating new&quot;); // This is a totally new chat let type = (this.type == &quot;group&quot;) ? &quot;room&quot; : this.type; let chat_info = await APISocket.post(`chat/`, { name: this.name, type: type, purpose: this.purpose, team: this.team, users: this.users }) console.log(&quot;Creating a chat returned&quot;, chat_info); return new Chat(chat_info); } } /** * @async * @summary * Enables guest access on this chat by generating a new {@link Chat#pin PIN}, and invalidate any existing guest sessions. */ async generateGuestURL(opts) { let options = Object.assign({}, { }, opts); let guest_response = await APISocket.get(`chat/${this.id}/generateUrl`) if (guest_response.constructor.name == &quot;Array&quot;) { return new Chat(guest_response[0]); } else { return new Chat(guest_response); } } /** * @async * @summary * Sends a chat message. * * @description * Sends a text message to a chat, and then triggers the `.on('message')` listeners with the content of the new message. * * @param {String} message The message to send */ async sendMessage(message) { if (!message || typeof message != &quot;string&quot;) return; if (!this.id) return; let message_props = { type: &quot;text&quot;, body: message } let result = APISocket.post(`chat/${this.id}/messages`, message_props) let msg_object = new ChatMessage(Object.assign(message_props, { from: APISocket.current_user, chat: this, created_at: new Date().toString() })); this._listeners.message.map((callback) =&gt; { this.messages.unshift(msg_object) callback.call(this, {}, this, msg_object); }); return new Promise((resolve, reject) =&gt; { resolve(msg_object); }); } /** * @async * @summary * Sends a file * * @param {Object} fileObj The file to send */ async sendFile(fileObj) { if (!fileObj) return; if (!this.id) return; // Request data let message_props = { type: &quot;filestack&quot;, chat_id: this.id, body: fileObj } message_props.body.extension = this._getFileExtension(fileObj); let result = APISocket.post(`chat/${this.id}/messages`, message_props) let msg_object = new ChatMessage(Object.assign(message_props, { from: APISocket.current_user, chat: this, created_at: new Date().toString() })); this._listeners.message.map((callback) =&gt; { this.messages.unshift(msg_object) callback.call(this, {}, this, msg_object); }); return new Promise((resolve, reject) =&gt; { resolve(msg_object); }); } /** * @summary * Adds user(s) to a chat * * @param {User[]} users The user(s) to add. Either supply a single User object, or * an array of Users to add each. * * @returns {Chat} Successfully adding will return `true` */ async addUser(users) { let add_response; if (typeof users === &quot;object&quot; &amp;&amp; users.constructor.name === &quot;User&quot;) { try { add_response = await APISocket.post(`chat/${this.id}/users`, { user: users.id }) } catch (err) { throw new Error(err); return false; } } else if (Array.isArray(users)) { return users.map(async (user) =&gt; { try { add_response = await APISocket.post(`chat/${this.id}/users`, { user }) } catch (err) { throw new Error(err); return false; } }) } else { throw new Error(&quot;Chat.addUser only accepts User object(s), recieved&quot;, typeof users); } } /** * @summary * Remoevs user(s) from a chat * * @param {User[]} users The user(s) to remove. Either supply a single User object, * or an array of Users to delete each. * * @returns {Chat} Successfully deleting will return `true` */ async removeUser(users) { let add_response; if (typeof users === &quot;object&quot; &amp;&amp; users.constructor.name === &quot;User&quot;) { try { add_response = await APISocket.delete(`chat/${this.id}/users/${users.id}`) } catch (err) { throw new Error(err); return false; } } else if (Array.isArray(users)) { return users.map(async (user) =&gt; { try { add_response = await APISocket.post(`chat/${this.id}/users/${user}`) } catch (err) { throw new Error(err); return false; } }) } else { throw new Error(&quot;Chat.addUser only accepts User object(s), recieved&quot;, typeof users); } } /** * @summary * Listen for changes to this chat coming in over the APISocket. * * @description * | Event | Description | * | --- | --- | * | `updated` | Chat information has changed. Callback will be called with the signature `callback(evt, chat)` with `evt` being the original socket event, and `chat` is the updated Chat object. This happens when a user changes the `purpose`, `locked`, or `name`. | * | `message` | New message to this chat, from someone else or from the current user. Callback will be called with the signature `callback(evt, chat, message)` with `evt` being the original socket event, `chat` is the Chat object with the new message inserted in `messages`, and `message` is the {@link ChatMessage} that was sent. | * * @param {String} evt The event to listen for * @param {function} callback The callback to fire when the event occurs */ on(evt, callback) { if (!this.id) return; if (!evt || !this._listeners.hasOwnProperty(evt)) return; if (!callback || typeof callback != &quot;function&quot;) return; this._listeners[evt].push(callback); } /** * @summary * Converts a chat to an HTML fragment for debugging purposes. * * @example * document.getElementById(&quot;chat_debug&quot;).innerHTML = my_chat.toHTML(); */ toHTML() { let name, second_line, messages; if (this.type == &quot;private&quot;) { let other_user = Skrumble.removeSelf(this.users); name = `${other_user.first_name} ${other_user.last_name}` second_line = &quot;&quot; } else { name = this.name; second_line = this.purpose; } if (this.messages.length) { messages = this.messages.reduce(function(acc, msg) { acc = (typeof acc == &quot;object&quot;) ? `${acc.toHTML()}&lt;br /&gt;\\n` : acc; return `${acc} ${msg.toHTML()}&lt;br /&gt;\\n`; }) } return ` &lt;header&gt; &lt;h1&gt;${name}&lt;/h1&gt; &lt;p&gt;${second_line}&lt;/p&gt; &lt;/header&gt; ${messages}`; } } × Search results Close "},"ChatMessage.js.html":{"id":"ChatMessage.js.html","title":"Source: ChatMessage.js","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser Source: ChatMessage.js import { APISocket } from &quot;./APISocket&quot;; import { Logger } from &quot;./Logger&quot;; import { User } from &quot;./User&quot;; import { Guest } from &quot;./Guest&quot;; (async function loadDependencies() { })() /** * @class ChatMessage * @classdesc * ChatMessage instances describe individual messages inside a {@link Chat} */ export class ChatMessage { constructor(opts) { /** * @prop type * @type {String} * @summary * The type of event this message is for. * * @description * ChatMessages don't just represent traditional text messages or files, but also several different types of notifications about the chat itself. Options are: * * | Type | Description | * | --- | --- | * | `text` | This is a text chat message, with the content in {@link ChatMessage#body `body`}. | * | `file` | A file message with the properties of the file on the {@link ChatMessage#file `file`} property. | * | `call_log` | A record of a call with this chat. Call logs for groups will have the `body.type` of `conference_started` (starting a call), `conference_ended` (call ended), `conference_join` (user joining call), or `conference_leave` (user leaving call). Private chats will have the `body.type` of `missed` or `call` (which will have `body.duration` with the duration of the call in seconds). | * | `voicemail` | A voicemail left by another user in a private chat. The {@link ChatMessage#file `file`} field will be a wav file of the message | * | `chat_renamed` | Group chat only. The `name` of this chat was changed. The `body` will be an object: `{ 'new': 'group new name', 'old': 'group previous name' }` | * | `chat_purpose` | Group chat only. The `purpose` of this chat was changed. The `body` will be an object: `{ 'new': 'group new purpose', 'old': 'group prev purpose' }` | * | `chat_locked` | Group chat only. A user has locked/unlocked a group. The `body` will be `1` if the group was locked, and `0` if it was unlocked | * | `participant_added` | Group chat only. User(s) have been added to the chat. The `body` will be an array of users that have been added. | * | `participant_removed` | Group chat only. User(s) have been removed from the chat. The `body` will be an array of users that have been removed. | * | `recording_video` | The recording of a group conference, along with an optional transcript. The attached file is the recording. | */ this.type = &quot;&quot; /** * @prop body * @type {String} * @summary * The content of the message. */ this.body = &quot;&quot; /** * @prop file * @type {Object} * @summary * Files attached to this message, or `false`. * * @description * For messages with a {@link ChatMessage#type `type`} of `file`, `recording_video`, or `voicemail`, this will be the information about the file. Messages of other types will have this set to `false`. * * | Property | Description | * | -------- | ----------- | * | `url` | Public URL to download this file | * | `created_at` | ISO 8601 string of the time the file was created | * | `name` | Full uploaded path and filename | * | `size` | Filesize in bytes | * | `filename` | Filename only | * | `thumb_url` | Thumbnail URL, for `png`, `jpg`, and `gif` files only | * | `thumbHeight` | Height in px of the thumbnail | * | `thumbWidth` | Width in px of the thumbnail | */ this.file = false; /** * @prop chat * @type {String} * @summary * The ID of the Chat this belongs to */ this.chat = &quot;&quot; /** * @prop created_at * @type {String} * @summary * The ISO 8601 string representing the time this message was created on the server */ this.created_at = &quot;&quot; /** * @prop from * @type {(User|Guest)} * @summary * Who this message was sent by. */ this.from = &quot;&quot; /** * @prop id * @type {String} * @summary * The unique ID of this message. */ this.id = &quot;&quot; /** * @prop language * @type {String} * @summary * The language this message was sent in. */ this.language = &quot;&quot; /** * @prop links * @type {String[]} * @summary * An array of URLs in this message. */ this.links = [] /** * @prop room_mentions * @type {Array} * @summary * An array of mentions to chats in this message. */ this.room_mentions = [] /** * @prop user_mentions * @type {Array} * @summary * An array of mentions to users in this message */ this.user_mentions = [] // Assign in passed values for(let [key, value] of Object.entries(opts)) { if (this.hasOwnProperty(key)) { if (key == &quot;from&quot; &amp;&amp; value.role) { if (value.role !== &quot;guest&quot;) value = new User(value); if (value.role === &quot;guest&quot;) value = new Guest(value); } this[key] = value; } else { // Logger.info(&quot;Key not found&quot;, key, value); } } } /** * @summary * Converts a chat to an HTML fragment for debugging purposes. * * @example * document.getElementById(&quot;chat_msg_debug&quot;) = chat_message.toHTML(); */ toHTML() { var date = new Date(this.created_at).toLocaleString(); var message = `&lt;em&gt;(${date})&lt;/em&gt; &lt;strong&gt;${this.from.first_name} ${this.from.last_name}&lt;/strong&gt;`; switch (this.type) { case &quot;text&quot;: this.body = (&quot;&quot; + this.body).replace(/((http|https|ftp):\\/\\/[\\w?=&amp;.\\/-;#~%-]+(?![\\w\\s?&amp;.\\/;#~%&quot;=-]*&gt;))/g, '&lt;a href=&quot;$1&quot; target=&quot;_blank&quot;&gt;$1&lt;/a&gt;') message += `: ${this.body}`; break; case &quot;call_log&quot;: switch (this.body.type) { case &quot;conference_started&quot;: message += ` started a call`; break; case &quot;conference_ended&quot;: message += ` ended the call`; break; case &quot;conference_join&quot;: message += ` joined the call`; break; case &quot;conference_leave&quot;: message += ` left the call`; break; case &quot;missed&quot;: message += ` called &lt;strong&gt;${this.body.to.first_name} ${this.body.to.last_name}&lt;/strong&gt; (missed)` break; case &quot;call&quot;: message += ` called &lt;strong&gt;${this.body.to.first_name} ${this.body.to.last_name}&lt;/strong&gt; &lt;em&gt;(${this.body.duration}s)&lt;/em&gt;` break; default: // debugger; } break; case &quot;participant_added&quot;: message += &quot; joined the conversation&quot;; break; case &quot;participant_removed&quot;: message += &quot; left the conversation&quot;; break; case &quot;chat_locked&quot;: if (!!this.body) { message += &quot; locked the conversation&quot;; } else { message += &quot; unlocked the conversation&quot;; } break; case &quot;chat_purpose&quot;: message += ` changed the purpose from &lt;em&gt;${this.body.old}&lt;/em&gt; to &lt;em&gt;${this.body.new}&lt;/em&gt;`; break; case &quot;chat_renamed&quot;: message += ` renamed the conversation from &lt;em&gt;${this.body.old}&lt;/em&gt; to &lt;em&gt;${this.body.new}&lt;/em&gt;`; break; case &quot;voicemail&quot;: message += ` left a voicemail [&lt;a href=&quot;${this.file.url}&quot; target=&quot;_blank&quot;&gt;link&lt;/a&gt;]`; break; case &quot;file&quot;: message += ` sent &lt;em&gt;${this.file.filename}&lt;/em&gt; [&lt;a href=&quot;${this.file.url}&quot; target=&quot;_blank&quot;&gt;link&lt;/a&gt;]`; break; case &quot;recording_video&quot;: message += ` made a recording [&lt;a href=&quot;${this.file.url}&quot; target=&quot;_blank&quot;&gt;link&lt;/a&gt;]`; break; case &quot;room&quot;: message = &quot;&quot;; break; default: // debugger; message = &quot;&quot;; break; } return message; } } × Search results Close "},"Department.js.html":{"id":"Department.js.html","title":"Source: Department.js","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser Source: Department.js import Logger from &quot;./Logger&quot; /** * @class Department * @classdesc * Departments are groups of users that can all recieve calls to that department, depending on the ring strategy. For applications implementing call center applications (with many agents recieving incoming {@link Call calls} to one extension). Departments are used for calling groups only, for information about chats with multiple users, see {@link Chat} * * * @summary * Creates a department * * @description * Departments are created with a list of {@link User users}, which defines which users are eligible to recieve calls for this department. */ export class Department { constructor() { /** * @prop extension * @type {(String|String[])} */ this.extension } } × Search results Close "},"Guest.js.html":{"id":"Guest.js.html","title":"Source: Guest.js","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser Source: Guest.js import { Logger } from &quot;./Logger&quot; /** * @class Guest * @classdesc * Guests are temporary users that are granted access to one group {@link Chat} using the chat's {@link Chat#guest_url guest URL}. */ export class Guest { constructor(options) { /** * @readonly * @prop id * @type {String} * @summary * The ID of the user, assigned by the API * */ this.id = &quot;&quot; /** * @prop first_name * @type {String} * @summary * The first name of the guest. */ this.first_name = &quot;&quot; /** * @prop last_name * @type {String} * @summary * The last name of the guest. */ this.last_name = &quot;&quot; /** * @prop avatar * @type {String} * @summary * The URL of the guest's avatar. */ this.avatar = &quot;&quot; /** * @prop email * @type {String} * @summary * The email address of the guest. */ this.email = &quot;&quot; /** * @prop chat_id * @type {String} * @summary * The {@link Chat#id Chat ID} this guest is valid for. */ this.chat_id = &quot;&quot; /* * @prop extensionSecret * @type {String} * @summray * The user's password for SIP phone registration. */ this.extension_secret = &quot;&quot;; /** * @prop role * @type {String} * @summary * The user's role on the team, possibilities are `admin` or `member` */ this.role = &quot;&quot; /** * @readonly * @prop teams * @type {Team[]} * @summary * A list of teams this user is on */ this.teams = [] /** * @prop caller_id_name * @type {String} * @summary * When making outbound calls, this will be the name field of the Caller ID, visible to the other caller. If this is blank * (default), the name will default to {@linkcode Team#caller_id_name Team.caller_id_name}. */ this.caller_id_name = &quot;&quot; /** * @prop caller_id_number * @type {String} * @summary * When making outbound calls, this will be the number field of the Caller ID, visible to the other caller. If this is blank (default), the name will default to {@linkcode Team#caller_id_number Team.caller_id_number}. */ this.caller_id_number = &quot;&quot; // Assign in passed values for(let [key, value] of Object.entries(options)) { if (this.hasOwnProperty(key)) { this[key] = value; } else { // Logger.info(&quot;Key not found in Guest&quot;, key, value); } } } } × Search results Close "},"Logger.js.html":{"id":"Logger.js.html","title":"Source: Logger.js","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser Source: Logger.js export const LOG_LEVEL = { ALL: 9, INFO: 3, WARN: 2, ERROR: 1, NONE: 0 }; // Default to logging everything let log_level = LOG_LEVEL.ALL; /** * @class Logger */ export class Logger { /** * Print something to the console as a message */ static log(...items) { if (log_level &gt;= LOG_LEVEL.INFO) { console.log.apply(this, items); } } /** * Print something to the console as an info message */ static info(...items) { if (log_level &gt;= LOG_LEVEL.INFO) { console.info.apply(this, items); } } /** * Print something to the console as a warning */ static warn(...items) { if (log_level &gt;= LOG_LEVEL.WARN) { console.warn.apply(this, items); } } /** * Print something to the console as an error */ static error(...items) { if (log_level &gt;= LOG_LEVEL.ERROR) { console.error.apply(this, items); } } /** * Sets the logging level */ static setLogLevel(level) { log_level = level; } } × Search results Close "},"Team.js.html":{"id":"Team.js.html","title":"Source: Team.js","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser Source: Team.js import { APISocket } from &quot;./APISocket&quot;; import { Logger } from &quot;./Logger&quot;; import { User } from &quot;./User&quot;; import axios from 'axios'; /** * @class Team * @classdesc * The settings and info for a team. * * @summary * Creates a team object * */ export class Team { constructor(opts) { /** * @prop id * @type {String} * @summary * Unique ID of the team. */ this.id = &quot;&quot;; /** * @prop owner * @type {User} * @summary * The User that created this team. */ this.owner = false; /** * @prop team_name * @type {String} * @summary * Display name of the team. */ this.team_name = &quot;&quot;; /** * @prop team_avatar * @type {String} * @summary * The URL of the team's avatar. */ this.team_avatar = &quot;&quot;; /** * @prop slug * @type {String} * @summary * Team name with special characters removed. Used to create URL-friendly guest links. */ this.slug = &quot;&quot;; /** * @prop country * @type {String} * @summary * Team's country. */ this.country = &quot;&quot;; /** * @prop city * @type {String} * @summary * Team's city. */ this.city = &quot;&quot;; /** * @prop state * @type {String} * @summary * Team's province or state */ this.state = &quot;&quot;; /** * @prop address_1 * @type {String} * @summary * Team's address line 1 */ this.address_1 = &quot;&quot;; /** * @prop address_2 * @type {String} * @summary * Team's address line 2 */ this.address_2 = &quot;&quot;; /** * @prop postal * @type {String} * @summary * Team's postal or zip code */ this.postal = &quot;&quot;; /** * @prop timzeon * @type {String} * @summary * The TZ string of this team's timezone */ this.timezone = &quot;&quot;; /** * @prop autoreception * @type {String} * @summary * What point of setting-up autoreception is complete. Options are `completed` @todo */ this.autoreception = &quot;&quot;; /** * @prop caller_id_name * @type {String} * @summary * The default caller ID name field for all members. * * @see {@link User#caller_id_name} */ this.caller_id_name = &quot;&quot;; /** * @prop caller_id_number * @type {String} * @summary * The default caller ID number field for all members. * * @see {@link User#caller_id_number} */ this.caller_id_number = &quot;&quot;; for(let [key, value] of Object.entries(opts)) { if (this.hasOwnProperty(key)) { this[key] = value; } else { // Logger.info(&quot;Key not found&quot;, key, value); } } } /** * Loads a team by ID * * @param {Object} opts Options for the request * @param {String} opts.id The ID of the team to load */ static async get(opts) { var options = Object.assign({}, { id: false }, opts); var team = await APISocket.get(`team/${options.id}?populate=departments&amp;users=true`) return new Team(team); } /** * @summary * Creates a team * * @description * Creates a team by first creating an Owner account, who is the first user * on the team. Then creates the team and assigns the Owner to it. NB: Team names are unique * * @param {Object} opts Options for the request * @param {String} opts.owner_first_name Owner's first name * @param {String} opts.owner_last_name Owner's last name * @param {String} opts.owner_email Owner's email. Used later for authentication and cannot be changed. * @param {String} opts.owner_password Owner's password * @param {String} opts.name Name of the team * @param {String} opts.country Team country * @param {String} opts.city Team city * @param {String} opts.state Team state * @param {String} [opts.referral_code] Referral code, if any * * @returns {Promise} Promise that will resolve with the newly created team if the team creation was successful, and be rejected with an error as the first argument if the attempt fails * * @example * let owner_email = &quot;owner@example.com&quot;; * let owner_password = &quot;hunter2&quot;; * * Team.create({ * owner_first_name: &quot;jane&quot;, * owner_last_name: &quot;doe&quot;, * owner_email, * owner_password, * name: &quot;My SDK Team&quot;, * country: &quot;Canada&quot;, * city: &quot;Toronto&quot;, * state: &quot;ON&quot; * }) * .then((newTeam) =&gt; { * console.log(&quot;new team created&quot;, newTeam); * * // You can log-in now as the owner * APISocket.login({ * email: owner_email, * password: owner_password * }) * }) * .catch((err) =&gt; console.error(&quot;team creation err&quot;, err)) */ static async create(opts) { var options = Object.assign({}, { owner_first_name: &quot;&quot;, owner_last_name: &quot;&quot;, owner_email: &quot;&quot;, owner_password: &quot;&quot;, name: &quot;&quot;, country: &quot;&quot;, city: &quot;&quot;, state: &quot;&quot;, referral_code: &quot;&quot; }, opts); let owner_exists; let owner_res; let team_res; // Check for required fields if (!options.owner_first_name) throw Error(&quot;Team.create requires an owner first name (opts.owner_first_name)&quot;); if (!options.owner_last_name) throw Error(&quot;Team.create requires an owner last name (opts.owner_last_name)&quot;); if (!options.owner_email) throw Error(&quot;Team.create requires an owner email (opts.owner_email)&quot;); if (!options.owner_password) throw Error(&quot;Team.create requires an owner password (opts.owner_password)&quot;); if (!options.name) throw Error(&quot;Team.create requires a team name (opts.name)&quot;); if (!options.country) throw Error(&quot;Team.create requires a team country (opts.country)&quot;); if (!options.city) throw Error(&quot;Team.create requires a team city (opts.city)&quot;); if (!options.state) throw Error(&quot;Team.create requires a team state (opts.state)&quot;); // Type-check fields if (typeof options.owner_first_name !== &quot;string&quot;) throw TypeError(`Team.create owner_first_name must be a string, received ${typeof options.owner_first_name}`); if (typeof options.owner_last_name !== &quot;string&quot;) throw TypeError(`Team.create owner_last_name must be a string, received ${typeof options.owner_last_name}`); if (typeof options.owner_email !== &quot;string&quot;) throw TypeError(`Team.create owner_email must be a string, received ${typeof options.owner_email}`); if (typeof options.owner_password !== &quot;string&quot;) throw TypeError(`Team.create owner_email must be a string, received ${typeof options.owner_email}`); if (typeof options.name !== &quot;string&quot;) throw TypeError(`Team.create name must be a string, received ${typeof options.name}`); if (typeof options.country !== &quot;string&quot;) throw TypeError(`Team.create country must be a string, received ${typeof options.country}`); if (typeof options.city !== &quot;string&quot;) throw TypeError(`Team.create city must be a string, received ${typeof options.city}`); if (typeof options.state !== &quot;string&quot;) throw TypeError(`Team.create state must be a string, received ${typeof options.state}`); // Check to see if the owner already exists try { owner_exists = await User.exists(options.owner_email) } catch (err) { throw Error(err); } if (owner_exists) { throw Error(&quot;Team.create can't use an existing owner&quot;); } else { // First create the team owner try { owner_res = await axios.post(`${APISocket.api_url}/v3/user`, { first_name: options.owner_first_name, last_name: options.owner_last_name, email: options.owner_email, password: options.owner_password, }); } catch(err) { throw Error(err); } // If the owner was created, create the team if (parseInt(owner_res.status, 10) === 201) { try { team_res = await axios.post(`${APISocket.api_url}/v3/team`, { team_name: options.name, owner: owner_res.data.id, country: options.country, city: options.city, state: options.state, ref: options.referral_code, }); } catch(err) { throw Error(err); } if (parseInt(team_res.status, 10) === 201) { return new Team(team_res.data); } else { throw Error(`Team.create failed to create a Team. Error ${team_res.status}: ${team_res.statusText}`) } } else { // Owner wasn't created properly throw Error(`Team.create failed to create a Team owner. Error ${owner_res.status}: ${owner_res.statusText}`) } } } } × Search results Close "},"User.js.html":{"id":"User.js.html","title":"Source: User.js","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser Source: User.js import { APISocket } from &quot;./APISocket&quot;; import { Logger } from &quot;./Logger&quot;; import axios from 'axios'; import _ from 'lodash'; /** * Fields that can be edited after creating a user * * @ignore */ let editable_fields = [ 'first_name', 'last_name', 'position', 'caller_id_name', 'caller_id_number', 'avatar', 'dateformat', 'forward', 'forward_number', 'home_number', 'mobile_number', 'language', 'latitude', 'longitude', 'password', 'state', 'status', 'theme', 'timeformat', 'timezone', 'tooltips', 'voicemail', 'website', 'work_number' ]; /** * @class User * @classdesc * The User class allows read access to user information. It's also possible to update User information with {@link User#save `save()`} if the User you're editing is yourself, or * if you're logged-in as an Admin. Static methods like {@link User#get `get()`} or {@link User#create `create()`} won't work on User instances, but will retrieve or create * User objects respectively. Instances of User will emit socket events when information about them is modified, see {@link User#on `on()`} for more details * * @summary * A Skrumble Team Member. * * * @example &lt;caption&gt;new User won't create users&lt;/caption&gt; * var testUser = new User({ * first_name &quot;test&quot;, * last_name: &quot;user&quot; * }); * * testUser.save(); // Returns error! Users must be created using * // static method User.create * * * @example &lt;caption&gt;Proper way to create a user&lt;/caption&gt; * var workingUser = User.create({ * email: &quot;user@example.com&quot;, // Required * plan: &quot;pro&quot;, // Required * first_name: &quot;Test&quot;, * last_name: &quot;User&quot; * }) * * // Listen for events * workingUser.on(&quot;change&quot;, function() { * console.log(workingUser, &quot;has been updated!&quot;); * }); * * // Persist changes * workingUser.position = &quot;CEO&quot;; * workingUser.save(); * * @see {@linkcode User.create} * @see {@linkcode User.invite} */ export class User { /** * @readonly * @prop id * @type {String} * @summary * The ID of the user, assigned by the API * */ id = &quot;&quot; /** * @prop first_name * @type {String} * @summary * The first name of the user */ first_name = &quot;&quot; /** * @prop last_name * @type {String} * @summary * The last name of the user */ last_name = &quot;&quot; /** * @prop position * @type {String} * @summary * Position in the team */ position = &quot;&quot; /** * @prop email * @type {String} * @summary * Email address. */ email = &quot;&quot; /** * @prop password * @type {String} * @summary * User password in plain text. */ password = &quot;&quot; /** * @prop avatar * @type {String} * @summary * URL to the user's avatar */ avatar = &quot;&quot; /** * @prop state * @type {String} * @summary * The state of the user, the options are `online` or * `offline` */ state = &quot;&quot; /** * @prop status * @type {String} * @summary * The call availability of this user */ status = &quot;&quot; /** * @prop role * @type {String} * @summary * The user's role on the team, possibilities are `admin` or `member` */ role = &quot;&quot; /** * @prop plan * @type {String} * @summary * The user's subscription type, either the Pro or Unlimited packages currently */ plan = &quot;&quot; /** * @prop language * @type {String} * @summary * The user's preferred interface language. * * @description * Currently this only modifies the interface language of app.skrumble.com, API responses won't be translated. Supported options are `en` and `es` */ language = &quot;en&quot; /** * @prop timezone * @type {String} * @summary * The TZ string value of the user's timezone */ timezone = &quot;&quot; /** * @prop timeformat * @type {String} * @summary * The user's preferred formatting of time values: `12-hour` or `24-hour` */ timeformat = &quot;&quot; /** * @prop dateformat * @type {String} * @summary * The formatting of dates */ dateformat = &quot;&quot; /** * @prop tooltips * @type {Boolean} * @summary * `true` if the user has requested UI tooltips for help on app.skrumble.com, `false` if disabled. */ tooltips = false /** * @prop created_at * @type {String} * @readonly * @summary * The datetime a user was created in ISO 8601 */ created_at = &quot;&quot; /** * @prop extension * @type {String[]} * @summary. * The list of extensions this user can be called at, based on their {@link CallRoute CallRoutes}. */ extension = [] /* * @prop extensionSecret * @type {String} * @summray * The user's password for SIP phone registration. */ extension_secret = &quot;&quot;; /** * @readonly * @prop teams * @type {Team[]} * @summary * A list of teams this user is on */ teams = [] /** * @prop voicemail * @type {boolean} * @summary * Is voicemail enabled for this user or not. If `true`, then calls that go unanswered after 30s will be * redirected to the user's voicemail box. `false` will disable voicemail entirely and missed calls will simply end. */ voicemail = true /** * @prop forward * @type {Boolean} * @summary * The user's call forwarding setting. `true` will forward all inbound calls to {@linkcode User#forward_number User.forward_number} and `false` will recieve calls normally */ forward = false /** * @prop forward_number * @type {Dialstring} * @summary * If {@link User#forward `User.forward`} is enabled, this will set where inbound calls are directed to */ forward_number = &quot;&quot; /** * @prop caller_id_name * @type {String} * @summary * When making outbound calls, this will be the name field of the Caller ID, visible to the other caller. If this is blank * (default), the name will default to {@linkcode Team#caller_id_name Team.caller_id_name}. */ caller_id_name = &quot;&quot; /** * @prop caller_id_number * @type {String} * @summary * When making outbound calls, this will be the number field of the Caller ID, visible to the other caller. If this is blank (default), the name will default to {@linkcode Team#caller_id_number Team.caller_id_number}. */ caller_id_number = &quot;&quot; /** * @prop work_number * @type {Dialstring} * @summary * The work number the user has entered in their profile. */ work_number = &quot;&quot; /** * @prop home_number * @type {Dialstring} * @summary * The home number the user has entered in their profile. */ home_number = &quot;&quot; /** * @prop mobile_number * @type {Dialstring} * @summary * The mobile number the user has entered in their profile. */ mobile_number = &quot;&quot; /** * @prop website * @type {String} * @summary * The website the user has entered in their profile. This should be a valid URL. */ website = &quot;&quot; /** * @prop latitude * @type {String} * @summary * The user's last recorded latitude. */ latitude = &quot;&quot; /** * @prop longitude * @type {String} * @summary * The user's last recorded longitude */ longitude = &quot;&quot; /** * @prop theme * @type {String} * @summary * The user's preferrerd desktop theme, the options are `dark` and `light`. New users wll default to `dark`. */ theme = &quot;dark&quot; /** * @prop accepted * @type {String} * @summary * The ISO8601 datestamp of when the user accepted the invitation to join the team. If the user was created and not invited, then this will be equal to the user's {@linkcode User#created_at created_at}. */ accepted = &quot;&quot; /** * @prop last_login * @type {String} * @summary * The ISO8601 datestamp of when this user last logged-in */ last_login = &quot;&quot; /** * @prop deleted_at * @type {String} * @summary * The ISO8601 datestamp of when this user was deactivated. Deactivated users cannot send or recieve chat messages or calls, and won't appear in chat participant lists or lists of users */ deleted_at = &quot;&quot; constructor(options) { // Assign in passed values for (let [key, value] of Object.entries(options)) { if (this.hasOwnProperty(key)) { this[key] = value; } else { // Logger.info(&quot;Key not found in User&quot;, key, value); } } } /** * @summary * Saves the details of a given user by sending a PATCH request. * * @description * For admins, this can be the information of any team member. For regular * users, it can only be their own information, or the API will return an error. * The original user object will be modified in-place with whatever values are applied successfully, and a copy will also passed into the promise. * * @returns {Promise} Promise that will resolve with the signature `resolver(updated_user)`, * where `updated_user` is the updated {@link User} object. or be rejected with * the signature `rejected(error_obj)`. * * @example * let me = await APISocket.login({ ...opts }) * me.mobile_number = &quot;555...&quot;; * me.avatar = &quot;http://gravatar.com/...&quot;; * me.language = &quot;es&quot;; * * me.save() * .then((me_updated) =&gt; console.log(me_updated)) * .catch((err) =&gt; console.error(err)); * */ async save() { let save_res; if (!this.id) return Logger.error(&quot;User.save must be run on a User object with an ID&quot;); // Only send the params this request that can be edited let request_options = _.pick(this, editable_fields); try { usr_save_res = await APISocket.patch(`user/${this.id}`, request_options); } catch (err) { } this.teams.map(async (team) =&gt; { try { save_res = await APISocket.patch(`team/${team.id}/users/${this.id}`, request_options); } catch (err) { } }) console.log(save_res); // Assign in passed values if (save_res) { for (let [key, value] of Object.entries(save_res)) { if (this.hasOwnProperty(key)) { this[key] = value; } else { // Logger.info(&quot;Key not found in User&quot;, key, value); } } } return this; } /** * @summary * Deactivates a user by sending a DELETE request. Deactivated users * cannot be reached or log-in, and don't count as an active subscription. * Deactivated users can be reactivated at any time * * @ignore */ async deactivate() { // TODO // DELETE /user/:id // DELETE /team/:id/users/:uid } /** * @summary * Registers a device ID with a user's account, so that they can be * sent push notifications * * @ignore */ async registerDevice() { // TODO // POST /user/:id/devices } /** * @summary * Updates an existing device registration for push notifications * * @ignore */ async updateDeviceRegistration() { // TODO // PATCH /user/:id/devices/:registration_id } /** * @summary * Sends a push notification to a user's device * * @ignore */ async sendDeviceNotification() { // TODO // POST /user/:id/devices/notification } /** * @summary * Unregisters a device ID from a user's account, so push notifications * will no longer be sent to the device * * @ignore */ async unregisterDevice() { // TODO // DELETE /user/:id/devices/:registration_id } /** * @static * @summary * Loads a list of all users visible for the logged-in user. * * @param {Object} opts The options for the request * @param {Number} opts.limit The maximum number of users to return * @param {Number} opts.skip The number to start &quot;limit&quot; at */ static async getAll(opts) { let options = Object.assign({}, { limit: 1000, skip: 0, }, opts); let users = []; let users_raw; try { users_raw = await APISocket.get(`user?populate=teams,extension,role,plan&amp;limit=${options.limit}&amp;skip=${options.skip}`); } catch(err) { throw new Error('Cannot load user list', err); } users_raw.map((user_info) =&gt; { users.push(new User(user_info)); }); return users; } /** * @static * @summary * Loads a specific user. * * @param {Object} opts The options for the request * @param {String} opts.id The ID of the user to find * * @returns {User} The found user if one exists */ static async get(opts) { let user_info; let options = Object.assign({}, { id: false, }, opts); if (!options.id) Logger.error(&quot;User.get requires an id&quot;); try { user_info = await APISocket.get(`user/${options.id}?populate=teams,extension,role,plan`) } catch (err) { throw new Error('Cannot find user', err); } return new User(user_info); } /** * @summary * Admin-only: creates a user on a Team without inviting them, bypassing * email confirmation and setting the password manually * * @param {Object} opts Options for the user to be created * @param {String} opts.first_name First name of the user * @param {String} opts.last_name Last name of the user * @param {String} opts.email Email of the user. Used in authentication and cannot be modified after creation * @param {String} opts.password Password of the user * @param {Team|String} opts.team Either a Team object, or the ID of a team * * @returns {Promise} Promise that will be resolved with the new User object as the first argument, or rejected with the error as the first argument * * @example * User.create({ * first_name: &quot;Jane&quot;, * last_name: &quot;Doe&quot;, * email: &quot;user@example.com&quot;, * password: &quot;hunter2&quot;, * team: MyTeamObj * }) * .then((newUser) =&gt; console.log(&quot;Created user&quot;, newUser.first_name, newUser.last_name)) * .catch((err) =&gt; console.error(&quot;Problem creating user&quot;, err)) */ static async create(opts) { let options = Object.assign({}, { first_name: '', last_name: '', email: '', password: '', team: '' }, opts); if (!options.email) return Logger.error('User.create requires an email'); if (!options.first_name) return Logger.error('User.create requires a first name'); if (!options.last_name) return Logger.error('User.create requires a last name'); if (!options.password) return Logger.error('User.create requires a password'); if (!options.team) return Logger.error('User.create requires a Team object or a team ID'); // If user passed a Team object, pull the ID from that if (options.team.constructor.name == &quot;Team&quot;) options.team = options.team.id const user = await APISocket.post(`team/${options.team}/add`, { first_name: options.first_name, last_name: options.last_name, email: options.email, password: options.password }); return new User(user); } /** * @summary * Admin-only: creates a user by sending them an email invite * * @ignore */ static invite(opts) { // TODO // POST /team/:id/invite } /** * @summary * Check if a user exists, in order to create one safely. * * @param {String} email Email address to check the existence of * @returns {Promise} Promise that will resolve with a boolean representing if a user exists or not, or rejected with the error as the first argument * * @example * User.exists(&quot;existinguser@example.com&quot;) * .then((userExists) =&gt; console.log(userExists ? 'user exists!' : 'no user with that email')) * .catch((err) =&gt; console.error(err)) */ static async exists(email = &quot;&quot;) { let exists_res; let response_code; if (!email) Logger.error(&quot;User.exists requires an email address&quot;); if (typeof email !== &quot;string&quot;) throw TypeError(`User.exists email must be a string, received ${typeof email}`); try { exists_res = await axios.post(`${APISocket.api_url}/v3/user/exist`, { email }); } catch(err) { return new Error(err); } response_code = parseInt(exists_res.status, 10); if (Math.floor(response_code / 100) === 2) { if ( typeof exists_res.data == &quot;object&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(exists_res.data, 'exists') ) { return !!exists_res.data.exists; } } else { return false; } } } × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser Classes Classes APISocket Chat ChatMessage Department Creates a department Guest Logger Team Creates a team object User A Skrumble Team Member. × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser @skrumble/js-sdk 0.1.4 InstallationThe JS SDK is distributed through the npm registry, which means it can be installed with npm. In a bash window, run: npm i --save @skrumble/js-sdk Or to install with yarn, run: yarn install @skrumble/js-sdkUsageThe SDK supports multiple formats for loading, depending on your environment: UMD var { Chat, APISocket } = require('@skrumble/js-sdk')ES6 import { Chat, APISocket } from '@skrumble/js-sdk'In case your environment doesn't support either, the SDK also exports a global called Skrumble, which contains the same classes as properties: let Chat = Skrumble.Chat let APISocket = Skrumble.APISocketConfiguring &amp; Logging-inFirst you'll need: Client credentials from the Skrumble Developer site Hostnames for the environment you're using, see the Environments list in the developer docs An existing team on the server import { Chat, APISocket } from '@skrumble/js-sdk'; let registeredUser, loadedChat APISocket.config({ client_id: &quot;iK47Sr....&quot;, client_secret: &quot;$2y$10$J...&quot;, api_hostname: &quot;sandbox.skrumble.com&quot;, auth_hostname: &quot;sandbox-auth.skrumble.com&quot; }) try { registeredUser = await APISocket.login({ email: &quot;skrumble_user@example.com&quot;, password: &quot;123456&quot; }) } catch(err) { throw new Error(err); } try { chatList = await Chat.getAll(); } catch(err) { throw new Error(err); } console.log(`Logged in as ${registeredUser.first_name}, found chat list of ${chatList}`); ContributingThe SDK is an open-source project, so Pull Requests and bug reports are encouraged. Before contributing, see the Github Issues page to ensure your issue/feature isn't a duplicate. DocumentationThere are separate NPM tasks for generating and serving docs. To generate the docs, run npm run docs, which will read the code in src/ and output it to docs/. To view it in a browser using SimpleHTTPServer, run npm run docs_serve. The docs should now be visible at localhost:5000/index.html TestingThe SDK currently uses mocha/chai as a testing suite. npm run test will run the tests and output results to the console. RoadmapThe goal of the SDK is to provide convenient access to the full functionality of the Skrumble REST API. For maintainers/contributors, unchecked items below are unimplemented, and therefore a good place to start contributing. Bold items are high-priority features. See our list of Github Issues for information about individual features. [ ] Teams [x] Create team [ ] Update team info [ ] Users [x] Create user (add to team) [x] Update user info [ ] Invite user [ ] Invite guest [x] Get one [x] Get all [x] Check existing [x] User login [x] Guest login [ ] Deactivate user [ ] Register device for notification [ ] Deregister device for notification [ ] Chat [x] Create [x] Get one [x] Get all [ ] Update chat info [ ] Delete chat [x] Generate guest url [ ] Mark as read [x] Add user to group [x] Remove user from group [ ] Messages [x] Send/recieve messages [ ] Send file by URL [ ] Send file by data [ ] Translate message [ ] Get unread [ ] Links [ ] Get links by chat [ ] Get links for user [ ] Files [ ] Get files by chat [ ] Get files for user [ ] Get file info [ ] Integrations [ ] Integration type support: [ ] Google [ ] Office365 [ ] Exchange [ ] Create integration [ ] Update integration [ ] Delete integration [ ] Contacts [ ] Create contact [ ] Update contact [ ] Delete contact [ ] Get one [ ] Get all [ ] Events [ ] Add event [ ] Update event [ ] Delete event [ ] Get all [ ] Get one [ ] Billing [ ] Add funds [ ] Get overview [ ] Get subscriptions [ ] Add billing address [ ] Get draft invoice PDF [ ] Get invoice PDF [ ] Credit Cards [ ] Add card [ ] Delete card [ ] Get all × Search results Close "},"APISocket.html":{"id":"APISocket.html","title":"APISocket","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser APISocket Allows connection to the Skrumble API through a persistent socket connection. Many other classes like User, Chat, and Department rely on APISocket to make requests. new APISocket() APISocket.js, line 19 Example something Properties api_url &lt;readonly&gt; String APISocket.js, line 67 auth_token &lt;readonly&gt; String The logged-in user's bearer token, this will automatically be appended to all future requests. APISocket.js, line 77 client_id &lt;readonly&gt; String The Client ID of the application. This is read-only, set using config APISocket.js, line 39 client_secret &lt;readonly&gt; String The Client Secret of the application. This is read-only, set using config APISocket.js, line 49 current_user &lt;readonly&gt; User After logging in and auth/refresh tokens are set properly, this will be the currently logged-in user for this socket connection. APISocket.js, line 99 hostname &lt;readonly&gt; String The hostname for future API reqeust, set using config APISocket.js, line 59 refresh_token &lt;readonly&gt; String The logged-in user's refresh token, this will automatically be used to refresh the APISocket#auth_token when the token has expired or requests begin failing with an HTTP code of 403 APISocket.js, line 88 socket Object The socket used to make requests. APISocket.js, line 29 Methods config(opts) &lt;async, static&gt; Configures the API socket for use, including the URLs and client tokens Parameters: Name Type Description opts Object Configuration options Properties Name Type Description client_id String Client ID of this application client_secret String Client secret of this application api_hostnae String Hostname for API requests, don't include protocol or port number auth_hostname String Hostname for Auth requests APISocket.js, line 540 connectSocket() &lt;async, static&gt; Initiates the socket connection. This connects a user to the socket and registers them for future changes. After the call to login completes, default behaviour will be to call this automatically. APISocket.js, line 312 delete(url, options) &lt;async, static&gt; Sends a DELETE request Parameters: Name Type Description url String Url to be passed to socket.io.get() options Object Options object to be passed to socket.io.get() APISocket.js, line 434 Returns: A promise object that either is resolved with success for sucessful (2xx) responses with the body of the response as the first argument. If the request fails (!= 2xx), the promise will be rejected with the body of the response as the first argument. Type Promise get(url, data) &lt;async, static&gt; Sends a GET request to the API socket. Parameters: Name Type Description url String Url to be passed to socket.io.get() data Object Data to be sent with the request APISocket.js, line 380 Returns: A promise object that either is resolved with success for sucessful (2xx) responses with the body of the response as the first argument. If the request fails (!= 2xx), the promise will be rejected with the body of the response as the first argument, and a JSON Websocket Response object as the second argument. Type Promise loadCurUser() &lt;async, static&gt; Load the current user based on their access token. Load the current user based on their access token APISocket.js, line 272 login(opts) &lt;async, static&gt; Authenticate a user and start listening for events over a persistent socket connection. Logs-in a user with the provided email and password. When the returned promise is resolved, it will return the authenticated user. Also connects user to the socket by default. Parameters: Name Type Description opts Object The options for this request Properties Name Type Argument Default Description email String Email address of the account to log-in password String Password of the account to log-in connect_socket Boolean &lt;optional&gt; true After a successful login, should the user's socket connection be initiated automatically. If this is disabled the socket connection must be created manually using connectSocket APISocket.js, line 136 Example Skrumble.APISocket.login({ email: &quot;myuser@gmail.com&quot;, password: &quot;123456&quot; }) .then((user) =&gt; { console.log(user, &quot;is now logged in!&quot;); }) .catch((err) =&gt; { console.error(&quot;Couldn't log-in!&quot;, err); }) loginGuest(opts) &lt;async, static&gt; Authenticates a guest and start listening for events over a persistent socket connection. Logs-in a guest user, which are given access only to one group conversation. When the returned promise is resolved, it will return the authenticated guest user. Also connects to the socket by default. Parameters: Name Type Description opts Object The options for this request Properties Name Type Description first_name String The first name of the guest last_name String The last name of the guest email String The email address of the guest pin String The PIN of the chat the guest is joining. chat String The ID of the chat the guest is joining. team String The slug of the team that owns the chat the guest is joining. APISocket.js, line 208 logout() &lt;static&gt; Logs out the current user by forcefully closing the socket and resetting APISocket.current_user APISocket.js, line 359 off(evt, callback) &lt;static&gt; Unbinds a listener bound using APISocket.on Parameters: Name Type Description evt String The event type to unbind callback function Callback to unbind from this event APISocket.js, line 520 on(evt, callback) &lt;static&gt; Listens for socket messages coming into the API socket. The Skrumble API will emit the following types of events: Event Description chat This is the event about a chat, including new messages, changes to the participant list, or name user Event is about a user that has changed: state, status, *_name, avatar, etc teamuser Event is about a user that has changed: state, status, *_name, avatar, etc team Changes to the team information conference Changes to a group call's status Because this is a static method, the events above will fire for any activity of that type. For example, chat will be triggered on changes to all chats on the current team. To monitor an individual chat, use Chat.on Parameters: Name Type Description evt String The event type to listen for callback function Callback to fire when the event occurs APISocket.js, line 503 patch(url, options) &lt;async, static&gt; Sends a POST request Parameters: Name Type Description url String Url to be passed to socket.io.get() options Object Options object to be passed to socket.io.get() APISocket.js, line 416 Returns: A promise object that either is resolved with success for sucessful (2xx) responses with the body of the response as the first argument. If the request fails (!= 2xx), the promise will be rejected with the body of the response as the first argument. Type Promise post(url, options) &lt;async, static&gt; Sends a POST request Parameters: Name Type Description url String Url to be passed to socket.io.get() options Object Options object to be passed to socket.io.get() APISocket.js, line 398 Returns: A promise object that either is resolved with success for sucessful (2xx) responses with the body of the response as the first argument. If the request fails (!= 2xx), the promise will be rejected with the body of the response as the first argument. Type Promise request(method, url, options) &lt;async, static&gt; Sends a request with a given HTTP method. Shorthand versions are available as APISocket.get(), post(), patch(), and delete() Parameters: Name Type Description method String HTTP Method to be used in the request url String Url to be passed to socket.io.get() options Object Options object to be passed to socket.io.get() APISocket.js, line 454 Returns: A promise object that either is resolved with success for sucessful (2xx) responses with the body of the response as the first argument. If the request fails (!= 2xx), the promise will be rejected with the body of the response as the first argument. Type Promise × Search results Close "},"Chat.html":{"id":"Chat.html","title":"Chat","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser Chat A chat comes in two major types (see the type property): Private chats between exactly two users Group chats, which can contain a mixture of users and guests. Groups must contain at least one user, but have no upper-limit. Groups also have the property roomNumber and pin, which allows outside callers to call the chat directly. new Chat() Chat.js, line 6 Properties avatar String The avatar for the chat. Only present on rooms Chat.js, line 122 created_at String ISO-8601 timestamp of when this chat was created. Chat.js, line 211 do_not_disturb Boolean Has this chat been set to silence notifications, from the perspective of the currently logged-in user. Chat.js, line 249 favourite Boolean Has this chat been marked as a favourite, from the perspective of the currently logged-in user. Chat.js, line 259 files Array.&lt;Object&gt; List of files sent in the chat. Chat.js, line 175 id String The ID of the chat. Chat.js, line 84 last_message_time String ISO-8601 timestamp of when this chat received it's last message Chat.js, line 239 last_seen String ISO-8601 timestamp of when this chat was last read, from the perspective of the currently logged-in user. Chat.js, line 230 links Array.&lt;Object&gt; List of URLs referenced in the messages of the chat. Chat.js, line 166 locked Boolean Locked groups will block guest access, and disconnect any guests. Unlocked groups allow guests to access the chat using the Chat#url property Chat.js, line 149 messages Array.&lt;ChatMessage&gt; The list of ChatMessages in this chat, in chronological order. Chat.js, line 193 name String The name of the chat. For private chats, this will be name of the other user. For a group chat, this will be a separate, unique name. Chat.js, line 103 pin Number PIN for calling to this chat via PSTN bridge, or for guest logins. Chat.js, line 157 purpose String The intended purpose of the chat. Only present on groups, this will be ignored for private chats Chat.js, line 113 roomNumber Number Room number for calling to this chat via PSTN bridge. Chat.js, line 130 team Team ID of the Team that this chat belongs to. Needed for the save() method. TODO: find a more elegant way to save this Chat.js, line 269 type String The type of the chat, options are private or group. Chat.js, line 93 unread Number Number of unread messages in this chat from the current user's perspective. Chat.js, line 139 updated_at String ISO-8601 timestmap of when this chat was last modified. Chat.js, line 220 url String The URL that guests can access this chat at. Only available on group chats. Chat.js, line 184 users Array.&lt;User&gt; The list of Users in this chat. Chat.js, line 202 Methods get(opts) &lt;async, static&gt; Gets a specific chat by ID. Loads chat messages by default, but for smaller responses this can be disabled with opts.load_messages = false Parameters: Name Type Description opts Object The options for this request Properties Name Type Argument Default Description id String The ID of the chat to load load_messages Boolean &lt;optional&gt; true true to load the chat message list, or false to disable message_limit Number &lt;optional&gt; 50 Maximum number of messages to load message_skip Number &lt;optional&gt; 0 Message number to start from Chat.js, line 441 getAll(opts) &lt;async, static&gt; Gets all chats that this user has access to, based on the pagination options limit, and skip Parameters: Name Type Description opts Object The options for this requiest Properties Name Type Argument Default Description limit Number &lt;optional&gt; 1000 Maximum number of chats to load skip Number &lt;optional&gt; 0 Chat number to start from Chat.js, line 404 addUser(users) &lt;async&gt; Adds user(s) to a chat Parameters: Name Type Description users Array.&lt;User&gt; The user(s) to add. Either supply a single User object, or an array of Users to add each. Chat.js, line 626 Returns: Successfully adding will return true Type Chat generateGuestURL() &lt;async&gt; Enables guest access on this chat by generating a new PIN, and invalidate any existing guest sessions. Chat.js, line 520 on(evt, callback) Listen for changes to this chat coming in over the APISocket. Event Description updated Chat information has changed. Callback will be called with the signature callback(evt, chat) with evt being the original socket event, and chat is the updated Chat object. This happens when a user changes the purpose, locked, or name. message New message to this chat, from someone else or from the current user. Callback will be called with the signature callback(evt, chat, message) with evt being the original socket event, chat is the Chat object with the new message inserted in messages, and message is the ChatMessage that was sent. Parameters: Name Type Description evt String The event to listen for callback function The callback to fire when the event occurs Chat.js, line 706 removeUser(users) &lt;async&gt; Remoevs user(s) from a chat Parameters: Name Type Description users Array.&lt;User&gt; The user(s) to remove. Either supply a single User object, or an array of Users to delete each. Chat.js, line 665 Returns: Successfully deleting will return true Type Chat save() &lt;async&gt; Saves a chat object by attempting to commit any dirty fields to the appropriate API endpoints. If the chat has an id and created_at date, then it will attempt to save the information. If Chat.js, line 486 sendFile(fileObj) &lt;async&gt; Sends a file Parameters: Name Type Description fileObj Object The file to send Chat.js, line 583 sendMessage(message) &lt;async&gt; Sends a chat message. Sends a text message to a chat, and then triggers the .on('message') listeners with the content of the new message. Parameters: Name Type Description message String The message to send Chat.js, line 546 toHTML() Converts a chat to an HTML fragment for debugging purposes. Chat.js, line 725 Example document.getElementById(&quot;chat_debug&quot;).innerHTML = my_chat.toHTML(); × Search results Close "},"ChatMessage.html":{"id":"ChatMessage.html","title":"ChatMessage","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser ChatMessage ChatMessage instances describe individual messages inside a Chat new ChatMessage() ChatMessage.js, line 9 Properties body String The content of the message. ChatMessage.js, line 48 chat String The ID of the Chat this belongs to ChatMessage.js, line 79 created_at String The ISO 8601 string representing the time this message was created on the server ChatMessage.js, line 88 file Object Files attached to this message, or false. For messages with a type of file, recording_video, or voicemail, this will be the information about the file. Messages of other types will have this set to false. Property Description url Public URL to download this file created_at ISO 8601 string of the time the file was created name Full uploaded path and filename size Filesize in bytes filename Filename only thumb_url Thumbnail URL, for png, jpg, and gif files only thumbHeight Height in px of the thumbnail thumbWidth Width in px of the thumbnail ChatMessage.js, line 71 from User|Guest Who this message was sent by. ChatMessage.js, line 96 id String The unique ID of this message. ChatMessage.js, line 104 language String The language this message was sent in. ChatMessage.js, line 112 links Array.&lt;String&gt; An array of URLs in this message. ChatMessage.js, line 120 room_mentions Array An array of mentions to chats in this message. ChatMessage.js, line 128 type String The type of event this message is for. ChatMessages don't just represent traditional text messages or files, but also several different types of notifications about the chat itself. Options are: Type Description text This is a text chat message, with the content in body. file A file message with the properties of the file on the file property. call_log A record of a call with this chat. Call logs for groups will have the body.type of conference_started (starting a call), conference_ended (call ended), conference_join (user joining call), or conference_leave (user leaving call). Private chats will have the body.type of missed or call (which will have body.duration with the duration of the call in seconds). voicemail A voicemail left by another user in a private chat. The file field will be a wav file of the message chat_renamed Group chat only. The name of this chat was changed. The body will be an object: { 'new': 'group new name', 'old': 'group previous name' } chat_purpose Group chat only. The purpose of this chat was changed. The body will be an object: { 'new': 'group new purpose', 'old': 'group prev purpose' } chat_locked Group chat only. A user has locked/unlocked a group. The body will be 1 if the group was locked, and 0 if it was unlocked participant_added Group chat only. User(s) have been added to the chat. The body will be an array of users that have been added. participant_removed Group chat only. User(s) have been removed from the chat. The body will be an array of users that have been removed. recording_video The recording of a group conference, along with an optional transcript. The attached file is the recording. ChatMessage.js, line 40 user_mentions Array An array of mentions to users in this message ChatMessage.js, line 136 Methods toHTML() Converts a chat to an HTML fragment for debugging purposes. ChatMessage.js, line 165 Example document.getElementById(&quot;chat_msg_debug&quot;) = chat_message.toHTML(); × Search results Close "},"Department.html":{"id":"Department.html","title":"Department","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser Department Departments are groups of users that can all recieve calls to that department, depending on the ring strategy. For applications implementing call center applications (with many agents recieving incoming calls to one extension). Departments are used for calling groups only, for information about chats with multiple users, see Chat new Department() Creates a department Departments are created with a list of users, which defines which users are eligible to recieve calls for this department. Department.js, line 3 Properties extension String|Array.&lt;String&gt; Department.js, line 23 × Search results Close "},"Guest.html":{"id":"Guest.html","title":"Guest","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser Guest Guests are temporary users that are granted access to one group Chat using the chat's guest URL. new Guest() Guest.js, line 4 Properties avatar String The URL of the guest's avatar. Guest.js, line 49 caller_id_name String When making outbound calls, this will be the name field of the Caller ID, visible to the other caller. If this is blank (default), the name will default to Team.caller_id_name. Guest.js, line 106 caller_id_number String When making outbound calls, this will be the number field of the Caller ID, visible to the other caller. If this is blank (default), the name will default to Team.caller_id_number. Guest.js, line 115 chat_id String The Chat ID this guest is valid for. Guest.js, line 67 email String The email address of the guest. Guest.js, line 58 first_name String The first name of the guest. Guest.js, line 31 id &lt;readonly&gt; String The ID of the user, assigned by the API Guest.js, line 22 last_name String The last name of the guest. Guest.js, line 40 role String The user's role on the team, possibilities are admin or member Guest.js, line 85 teams &lt;readonly&gt; Array.&lt;Team&gt; A list of teams this user is on Guest.js, line 96 × Search results Close "},"Logger.html":{"id":"Logger.html","title":"Logger","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser Logger new Logger() Logger.js, line 13 Methods error() &lt;static&gt; Print something to the console as an error. Print something to the console as an error Logger.js, line 52 info() &lt;static&gt; Print something to the console as an info message. Print something to the console as an info message Logger.js, line 32 log() &lt;static&gt; Print something to the console as a message. Print something to the console as a message Logger.js, line 22 setLogLevel() &lt;static&gt; Sets the logging level. Sets the logging level Logger.js, line 62 warn() &lt;static&gt; Print something to the console as a warning. Print something to the console as a warning Logger.js, line 42 × Search results Close "},"Team.html":{"id":"Team.html","title":"Team","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser Team The settings and info for a team. new Team() Creates a team object Team.js, line 6 Properties address_1 String Team's address line 1 Team.js, line 98 address_2 String Team's address line 2 Team.js, line 107 autoreception String What point of setting-up autoreception is complete. Options are completed @todo Team.js, line 133 caller_id_name String The default caller ID name field for all members. Team.js, line 144 See: User#caller_id_name caller_id_number String The default caller ID number field for all members. Team.js, line 155 See: User#caller_id_number city String Team's city. Team.js, line 80 country String Team's country. Team.js, line 71 id String Unique ID of the team. Team.js, line 26 owner User The User that created this team. Team.js, line 35 postal String Team's postal or zip code Team.js, line 116 slug String Team name with special characters removed. Used to create URL-friendly guest links. Team.js, line 62 state String Team's province or state Team.js, line 89 team_avatar String The URL of the team's avatar. Team.js, line 53 team_name String Display name of the team. Team.js, line 44 timezone String The TZ string of this team's timezone Team.js, line 125 Methods create(opts) &lt;async, static&gt; Creates a team Creates a team by first creating an Owner account, who is the first user on the team. Then creates the team and assigns the Owner to it. NB: Team names are unique Parameters: Name Type Description opts Object Options for the request Properties Name Type Argument Description owner_first_name String Owner's first name owner_last_name String Owner's last name owner_email String Owner's email. Used later for authentication and cannot be changed. owner_password String Owner's password name String Name of the team country String Team country city String Team city state String Team state referral_code String &lt;optional&gt; Referral code, if any Team.js, line 232 Returns: Promise that will resolve with the newly created team if the team creation was successful, and be rejected with an error as the first argument if the attempt fails Type Promise Example let owner_email = &quot;owner@example.com&quot;; let owner_password = &quot;hunter2&quot;; Team.create({ owner_first_name: &quot;jane&quot;, owner_last_name: &quot;doe&quot;, owner_email, owner_password, name: &quot;My SDK Team&quot;, country: &quot;Canada&quot;, city: &quot;Toronto&quot;, state: &quot;ON&quot; }) .then((newTeam) =&gt; { console.log(&quot;new team created&quot;, newTeam); // You can log-in now as the owner APISocket.login({ email: owner_email, password: owner_password }) }) .catch((err) =&gt; console.error(&quot;team creation err&quot;, err)) get(opts) &lt;async, static&gt; Loads a team by ID. Loads a team by ID Parameters: Name Type Description opts Object Options for the request Properties Name Type Description id String The ID of the team to load Team.js, line 174 × Search results Close "},"User.html":{"id":"User.html","title":"User","body":" Skrumble JS SDK Classes APISocketChatChatMessageDepartmentGuestLoggerTeamUser User The User class allows read access to user information. It's also possible to update User information with save() if the User you're editing is yourself, or if you're logged-in as an Admin. Static methods like get() or create() won't work on User instances, but will retrieve or create User objects respectively. Instances of User will emit socket events when information about them is modified, see on() for more details new User() A Skrumble Team Member. User.js, line 39 See: User.create User.invite Examples new User won't create users var testUser = new User({ first_name &quot;test&quot;, last_name: &quot;user&quot; }); testUser.save(); // Returns error! Users must be created using // static method User.create Proper way to create a user var workingUser = User.create({ email: &quot;user@example.com&quot;, // Required plan: &quot;pro&quot;, // Required first_name: &quot;Test&quot;, last_name: &quot;User&quot; }) // Listen for events workingUser.on(&quot;change&quot;, function() { console.log(workingUser, &quot;has been updated!&quot;); }); // Persist changes workingUser.position = &quot;CEO&quot;; workingUser.save(); Properties accepted String The ISO8601 datestamp of when the user accepted the invitation to join the team. If the user was created and not invited, then this will be equal to the user's created_at. User.js, line 378 avatar String URL to the user's avatar User.js, line 138 caller_id_name String When making outbound calls, this will be the name field of the Caller ID, visible to the other caller. If this is blank (default), the name will default to Team.caller_id_name. User.js, line 297 caller_id_number String When making outbound calls, this will be the number field of the Caller ID, visible to the other caller. If this is blank (default), the name will default to Team.caller_id_number. User.js, line 306 created_at &lt;readonly&gt; String The datetime a user was created in ISO 8601 User.js, line 231 dateformat String The formatting of dates User.js, line 212 deleted_at String The ISO8601 datestamp of when this user was deactivated. Deactivated users cannot send or recieve chat messages or calls, and won't appear in chat participant lists or lists of users User.js, line 396 email String Email address. User.js, line 122 extension Array.&lt;String&gt; User.js, line 240 first_name String The first name of the user User.js, line 98 forward Boolean The user's call forwarding setting. true will forward all inbound calls to User.forward_number and false will recieve calls normally User.js, line 278 forward_number Dialstring If User.forward is enabled, this will set where inbound calls are directed to User.js, line 287 home_number Dialstring The home number the user has entered in their profile. User.js, line 324 id &lt;readonly&gt; String The ID of the user, assigned by the API User.js, line 90 language String The user's preferred interface language. Currently this only modifies the interface language of app.skrumble.com, API responses won't be translated. Supported options are en and es User.js, line 185 last_login String The ISO8601 datestamp of when this user last logged-in User.js, line 387 last_name String The last name of the user User.js, line 106 latitude String The user's last recorded latitude. User.js, line 351 longitude String The user's last recorded longitude User.js, line 360 mobile_number Dialstring The mobile number the user has entered in their profile. User.js, line 333 password String User password in plain text. User.js, line 130 plan String The user's subscription type, either the Pro or Unlimited packages currently User.js, line 173 position String Position in the team User.js, line 114 role String The user's role on the team, possibilities are admin or member User.js, line 164 state String The state of the user, the options are online or offline User.js, line 147 status String The call availability of this user User.js, line 155 teams &lt;readonly&gt; Array.&lt;Team&gt; A list of teams this user is on User.js, line 259 theme String The user's preferrerd desktop theme, the options are dark and light. New users wll default to dark. User.js, line 369 timeformat String The user's preferred formatting of time values: 12-hour or 24-hour User.js, line 203 timezone String The TZ string value of the user's timezone User.js, line 194 tooltips Boolean true if the user has requested UI tooltips for help on app.skrumble.com, false if disabled. User.js, line 221 voicemail boolean Is voicemail enabled for this user or not. If true, then calls that go unanswered after 30s will be redirected to the user's voicemail box. false will disable voicemail entirely and missed calls will simply end. User.js, line 269 website String The website the user has entered in their profile. This should be a valid URL. User.js, line 342 work_number Dialstring The work number the user has entered in their profile. User.js, line 315 Methods create(opts) &lt;async, static&gt; Admin-only: creates a user on a Team without inviting them, bypassing email confirmation and setting the password manually Parameters: Name Type Description opts Object Options for the user to be created Properties Name Type Description first_name String First name of the user last_name String Last name of the user email String Email of the user. Used in authentication and cannot be modified after creation password String Password of the user team Team | String Either a Team object, or the ID of a team User.js, line 631 Returns: Promise that will be resolved with the new User object as the first argument, or rejected with the error as the first argument Type Promise Example User.create({ first_name: &quot;Jane&quot;, last_name: &quot;Doe&quot;, email: &quot;user@example.com&quot;, password: &quot;hunter2&quot;, team: MyTeamObj }) .then((newUser) =&gt; console.log(&quot;Created user&quot;, newUser.first_name, newUser.last_name)) .catch((err) =&gt; console.error(&quot;Problem creating user&quot;, err)) exists(email) &lt;async, static&gt; Check if a user exists, in order to create one safely. Parameters: Name Type Description email String Email address to check the existence of User.js, line 686 Returns: Promise that will resolve with a boolean representing if a user exists or not, or rejected with the error as the first argument Type Promise Example User.exists(&quot;existinguser@example.com&quot;) .then((userExists) =&gt; console.log(userExists ? 'user exists!' : 'no user with that email')) .catch((err) =&gt; console.error(err)) get(opts) &lt;async, static&gt; Loads a specific user. Parameters: Name Type Description opts Object The options for the request Properties Name Type Description id String The ID of the user to find User.js, line 587 Returns: The found user if one exists Type User getAll(opts) &lt;async, static&gt; Loads a list of all users visible for the logged-in user. Parameters: Name Type Description opts Object The options for the request Properties Name Type Description limit Number The maximum number of users to return skip Number The number to start &quot;limit&quot; at User.js, line 552 save() &lt;async&gt; Saves the details of a given user by sending a PATCH request. For admins, this can be the information of any team member. For regular users, it can only be their own information, or the API will return an error. The original user object will be modified in-place with whatever values are applied successfully, and a copy will also passed into the promise. User.js, line 437 Returns: Promise that will resolve with the signature resolver(updated_user), where updated_user is the updated User object. or be rejected with the signature rejected(error_obj). Type Promise Example let me = await APISocket.login({ ...opts }) me.mobile_number = &quot;555...&quot;; me.avatar = &quot;http://gravatar.com/...&quot;; me.language = &quot;es&quot;; me.save() .then((me_updated) =&gt; console.log(me_updated)) .catch((err) =&gt; console.error(err)); × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
