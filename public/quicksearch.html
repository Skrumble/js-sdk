<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"APISocket.js.html":{"id":"APISocket.js.html","title":"Source: APISocket.js","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams Source: APISocket.js import axios from 'axios'; import io from \"socket.io-client\" import { User } from \"./User\"; import { Team } from \"./Team\"; import { Logger } from \"./Logger\"; import { Guest } from \"./Guest\"; import { removeTrailingSlash } from \"../Skrumble\"; /** * @class * @hideconstructor * @classdesc * Allows connection to the Skrumble API through a persistent socket connection. Many other classes like {@link User}, {@link Chat}, and {@link Department} rely on APISocket to make requests. */ export class APISocket { constructor(opts) { /** * @prop socket * @type {Object} * @summary * The socket used to make requests. */ this.socket = false; /** * @readonly * @prop client_id * @type {String} * @summary * The Client ID of the application. This is read-only, set using {@link config} */ this.client_id = \"\"; /** * @readonly * @prop client_secret * @type {String} * @summary * The Client Secret of the application. This is read-only, set using {@link config} */ this.client_secret = \"\"; /** * @readonly * @prop hostname * @type {String} * @summary * The hostname for future API reqeust, set using {@link config} */ this.hostname = \"\"; /** * @readonly * @prop api_url * @type {String} * */ this.api_url = \"https://app.skrumble.com\"; /** * @readonly * @prop auth_token * @type {String} * @summary * The logged-in user's bearer token, this will automatically be appended to all future requests. */ this.auth_token = \"\"; /** * @readonly * @prop refresh_token * @type {String} * @summary * The logged-in user's refresh token, this will automatically be used to refresh the {@link APISocket#auth_token} * when the token has expired or requests begin failing with an HTTP code of 403 */ this.refresh_token = \"\"; /** * @readonly * @prop current_user * @type {User} * @summary * After logging in and auth/refresh tokens are set properly, this will be the currently logged-in user * for this socket connection. */ this.current_user = false; } /** * @summary * Authenticate a user and start listening for events over a persistent socket connection. * * @description * Logs-in a user with the provided email and password. When the returned promise * is resolved, it will return the authenticated user. Also connects user to the socket by default. See {@tutorial logging-in} for more * * @memberof APISocket * @param {Object} opts The options for this request * @param {String} opts.email Email address of the account to log-in * @param {String} opts.password Password of the account to log-in * @param {Boolean} [opts.connect_socket=true] After a successful login, should the user's socket * connection be initiated automatically. If this is disabled the socket connection must be created * manually using {@link connectSocket} * * @static * @tutorial logging-in * @example * APISocket.login({ * email: \"myuser@gmail.com\", * password: \"123456\" * }) * .then((user) =&gt; { * console.log(user, \"is now logged in!\"); * }) * .catch((err) =&gt; { * console.error(\"Couldn't log-in!\", err); * }) * */ static async login(opts) { let fields_missing = []; var options = Object.assign({}, { email: false, password: false, connect_socket: true }, opts); if (!options.email) fields_missing.push(\"email\"); if (!options.password) fields_missing.push(\"password\"); if (fields_missing.length &gt; 0) { throw new Error(\"Login error, fields missing:\", fields_missing.join(', ')) } let auth_url = `https://${this.auth_hostname}/v1/login-user` // Get the user's token and refresh token let auth_result = await axios({ method: \"post\", url: auth_url, data: { grant_type: \"password\", username: options.email, password: options.password, client_id: this.client_id, client_secret: this.client_secret } }); if (Math.floor(auth_result.status/100) !== 2) { throw new Error(err); } else { if (auth_result.data.access_token) this.access_token = auth_result.data.access_token; if (auth_result.data.refresh_token) this.refresh_token = auth_result.data.refresh_token; if (options.connect_socket &amp;&amp; this.access_token &amp;&amp; this.refresh_token) { var SocketRegistered = await this.connectSocket(); let cur_user = new User(await this.loadCurUser()); let user_teams = []; // Load all teams by ID for (var i = 0; i &lt; cur_user.teams.length; i++) { let team = await Team.get({ id: cur_user.teams[i].id }) user_teams.push(team); } cur_user.teams = user_teams; this.current_user = cur_user; } else { throw new Error(\"Socket registration failed\", auth_result); } } return this.current_user; } /** * @summary * Authenticates a guest and start listening for events over a persistent socket connection. * * @description * Logs-in a guest user, which are given access only to one group conversation. When the returned * promise is resolved, it will return the authenticated guest user. Also connects to the socket * by default. * * @memberof APISocket * @param {Object} opts The options for this request * @param {String} opts.first_name The first name of the guest * @param {String} opts.last_name The last name of the guest * @param {String} opts.email The email address of the guest * @param {String} opts.pin The {@link Chat#pin PIN} of the chat the guest is joining. * @param {String} opts.chat The {@link Chat#id ID} of the chat the guest is joining. * @param {String} opts.team The {@link Team#slug slug} of the team that owns the chat * the guest is joining. * */ static async loginGuest(opts) { console.log(\"Logging guest in with options\", opts); let fields_missing = []; let options = Object.assign({}, { first_name: false, last_name: false, email: false, pin: false, chat: false, team: false, }, opts); if (!options.email) fields_missing.push('email'); if (!options.first_name) fields_missing.push('first_name'); if (!options.last_name) fields_missing.push('last_name'); if (!options.pin) fields_missing.push('pin'); if (!options.chat) fields_missing.push('chat'); if (!options.team) fields_missing.push('team'); if (fields_missing.length &gt; 0) { throw new Error(\"Guest login error, fields missing:\", fields_missing.join(', ')) } let auth_url = `${this.api_url}guest/join`; let auth_result = await axios({ method: 'POST', url: auth_url, data: options }) if (Math.floor(auth_result.status/100) !== 2) { throw new Error(err); } else { if (auth_result.data.access_token) this.access_token = auth_result.data.access_token; if (auth_result.data.refresh_token) this.refresh_token = auth_result.data.refresh_token; if (this.access_token &amp;&amp; this.refresh_token) { var SocketRegistered = await this.connectSocket(); let cur_user = new Guest(await this.loadCurUser()); let user_teams = []; // Load all teams by ID for (var i = 0; i &lt; cur_user.teams.length; i++) { let team = await Team.get({ id: cur_user.teams[i].id }) user_teams.push(team); } cur_user.teams = user_teams; this.current_user = cur_user; } else { throw new Error(\"Socket registration failed\", auth_result); } } return this.current_user; } /** * Load the current user based on their access token * * @memberof APISocket * @static */ static async loadCurUser() { var user_result = await APISocket.get(`user/me?populate=teams&amp;extension=true`) // User is on one team: normalize values that are stored on the TeamUser object if (user_result.teams.length === 1) { // Properties defined on the TeamUser that need to be normalized back into actual user properties var team_user = await APISocket.get(`team/${user_result.teams[0].id}/users/${user_result.id}`) for (let [key, value] of Object.entries(team_user)) { user_result[key] = value; } } // Rename/remap fields user_result.extension_secret = (\" \" + user_result.extensionSecret).slice(1); delete user_result.extensionSecret; return user_result; } /** * @static * @async * @summary * Initiates the socket connection. * * @description * This connects a user to the socket and registers them for future changes. After the call to `login` completes, default behaviour will be to call this automatically. * */ static connectSocket() { return new Promise((resolve, reject) =&gt; { const socket = io( `${this.api_url}`, { path: '/socket.io/', transports: ['websocket'], query: { '__sails_io_sdk_version': '1.1.13', '__sk_js_sdk_version': '0.1.1' } } ); this.socket = socket; socket.on('connect', async () =&gt; { try { let register_res = await APISocket.post(`socket/register`) resolve(true); } catch(err) { reject(err); } }); socket.on('connect_error', onConnectError) socket.on('connect_timeout', onConnectError) socket.on('connect_timeout', onConnectError) const onConnectError = () =&gt; { console.log(\"connection error\"); reject(false); } }); } /** * @static * @summary * Logs out the current user by forcefully closing the socket and resetting APISocket.current_user * */ static logout() { this.socket = false; this.current_user = false; } /** * @static * @async * @summary * Sends a GET request to the API socket. * * @param {String} url - Url to be passed to socket.io.get() * @param {Object} data - Data to be sent with the request * * @returns {Promise} - A promise object that either is resolved * with success for sucessful (`2xx`) responses with the body of the response * as the first argument. If the request fails (`!= 2xx`), the promise will * be rejected with the body of the response as the first argument, and a * JSON Websocket Response object as the second argument. */ static get(url, data, append_url = true) { return APISocket.request('get', url, data, append_url); } /** * @static * @async * @summary * Sends a POST request * * @param {String} url - Url to be passed to socket.io.get() * @param {Object} options - Options object to be passed to socket.io.get() * @returns {Promise} - A promise object that either is resolved * with success for sucessful (`2xx`) responses with the body of the response * as the first argument. If the request fails (`!= 2xx`), the promise will * be rejected with the body of the response as the first argument. */ static post(url, data, append_url = true) { return APISocket.request('post', url, data, append_url); } /** * @static * @async * @summary * Sends a POST request * * @param {String} url - Url to be passed to socket.io.get() * @param {Object} options - Options object to be passed to socket.io.get() * @returns {Promise} - A promise object that either is resolved * with success for sucessful (`2xx`) responses with the body of the response * as the first argument. If the request fails (`!= 2xx`), the promise will * be rejected with the body of the response as the first argument. */ static patch(url, data, append_url = true) { return APISocket.request('patch', url, data, append_url); } /** * @static * @async * @summary * Sends a DELETE request * * @param {String} url - Url to be passed to socket.io.get() * @param {Object} options - Options object to be passed to socket.io.get() * @returns {Promise} - A promise object that either is resolved * with success for sucessful (`2xx`) responses with the body of the response * as the first argument. If the request fails (`!= 2xx`), the promise will * be rejected with the body of the response as the first argument. */ static delete(url, data, append_url = true) { return APISocket.request('delete', url, data, append_url); } /** * @static * @async * @summary * Sends a request with a given HTTP method. Shorthand versions are available * as APISocket.get(), post(), patch(), and delete() * * @param {String} method - HTTP Method to be used in the request * @param {String} url - Url to be passed to socket.io.get() * @param {Object} options - Options object to be passed to socket.io.get() * @returns {Promise} - A promise object that either is resolved * with success for sucessful (`2xx`) responses with the body of the response * as the first argument. If the request fails (`!= 2xx`), the promise will * be rejected with the body of the response as the first argument. */ static request(method, url, data, append_url = true) { return new Promise((resolve, reject) =&gt; { this.socket.emit(method, { url: (append_url) ? `${APISocket.api_url}/v3/${url}` : url, headers: { \"Authorization\": `Bearer ${this.access_token}` }, method, data, }, async (res) =&gt; { if (Math.floor(res.statusCode/100) === 2) { resolve(res.body, res); } else { throw new Error(`${res.statusCode} error: ${res.body}`); reject(res.body, res); } } ) }) } /** * @static * @summary * Listens for socket messages coming into the API socket. * * @description * The Skrumble API will emit the following types of events: * * | Event | Description | * | --- | --- | * | chat | This is the event about a chat, including new messages, changes to the participant list, or name | * | user | Event is about a user that has changed: `state`, `status`, `*_name`, `avatar`, etc | * | teamuser | Event is about a user that has changed: `state`, `status`, `*_name`, `avatar`, etc | * | team | Changes to the team information | * | conference | Changes to a group call's status | * * Because this is a static method, the events above will fire for any activity of that type. For example, `chat` will be triggered on * changes to all chats on the current team. To monitor an individual chat, use {@link Chat.on} * * @param {String} evt The event type to listen for * @param {Function} callback Callback to fire when the event occurs */ static on(evt, callback) { if (this.socket) { this.socket.on(evt, callback); } else { Logger.warn(\"Socket not connected\"); } } /** * @static * @summary * Unbinds a listener bound using {@link APISocket.on} * * @param {String} evt The event type to unbind * @param {function} callback Callback to unbind from this event */ static off(evt, callback) { if (this.socket) { this.socket.off(evt, callback); } else { Logger.warn(\"Socket not connected\"); } } /** * @static * @summary * Configures the API socket for use, including the URLs and client tokens * * @param {Object} opts - Configuration options * @param {String} opts.client_id - Client ID of this application * @param {String} opts.client_secret - Client secret of this application * @param {String} opts.api_hostnae - Hostname for API requests, don't include protocol or port number * @param {String} opts.auth_hostname - Hostname for Auth requests */ static async config(opts) { var options = Object.assign({}, { client_id: false, client_secret: false, api_hostname: \"app.skrumble.com\", auth_hostname: \"app.skrumble.com\" }, opts); if (options.client_id) { this.client_id = options.client_id; } else { throw new Error(\"client_id is required\"); } if (options.client_secret) { this.client_secret = options.client_secret; } else { throw new Error(\"client_id is required\"); } if (typeof options.api_hostname == \"string\" &amp;&amp; !options.api_hostname.match(/^\\s*$/gm)) { this.hostname = removeTrailingSlash(options.api_hostname); this.api_url = `https://${this.hostname}`; } if (typeof options.auth_hostname == \"string\" &amp;&amp; !options.auth_hostname.match(/^\\s*$/gm)) { this.auth_hostname = removeTrailingSlash(options.auth_hostname); } } } × Search results Close "},"Chat.js.html":{"id":"Chat.js.html","title":"Source: Chat.js","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams Source: Chat.js import { APISocket } from \"./APISocket\"; import { Logger } from \"./Logger\"; import { User } from \"./User\"; import { Guest } from \"./Guest\"; import { ChatMessage } from \"./ChatMessage\"; /** * @class * @hideconstructor * @classdesc * A chat comes in two major types (see the `type` property): * * * **Private** chats between exactly two {@link User users} * * **Group** chats, which can contain a mixture of users and {@link Guest guests}. Groups must contain at least one user, but have no upper-limit. Groups also have the property `roomNumber` and `pin`, which allows outside callers to call the chat directly. */ export class Chat { _mimeTypes = { 'ai' : 'application/postscript', 'au' : 'audio/basic', 'avi' : 'video/x-msvideo', 'bat' : 'text/plain', 'bmp' : 'image/x-ms-bmp', 'c' : 'text/plain', 'css' : 'text/css', 'doc' : 'application/msword', 'dot' : 'application/msword', 'eps' : 'application/postscript', 'gif' : 'image/gif', 'h' : 'text/plain', 'htm' : 'text/html', 'html' : 'text/html', 'jpeg' : 'image/jpeg', 'js' : 'application/x-javascript', 'json' : 'application/json', 'mov' : 'video/quicktime', 'movie' : 'video/x-sgi-movie', 'mp2' : 'audio/mpeg', 'mp3' : 'audio/mpeg', 'mp4' : 'video/mp4', 'mpeg' : 'video/mpeg', 'numbers': 'application/octet-stream', 'pdf' : 'application/pdf', 'png' : 'image/png', 'pot' : 'application/vnd.ms-powerpoint', 'ppa' : 'application/vnd.ms-powerpoint', 'ppm' : 'image/x-portable-pixmap', 'pps' : 'application/vnd.ms-powerpoint', 'ppt' : 'application/vnd.ms-powerpoint', 'pptx' : 'application/vnd.ms-powerpoint', 'ps' : 'application/postscript', 'pwz' : 'application/vnd.ms-powerpoint', 'py' : 'text/x-python', 'pyc' : 'application/x-python-code', 'pyo' : 'application/x-python-code', 'qt' : 'video/quicktime', 'tif' : 'image/tiff', 'txt' : 'text/plain', 'vcf' : 'text/x-vcard', 'wav' : 'audio/x-wav', 'wiz' : 'application/msword', 'wsdl' : 'application/xml', 'xbm' : 'image/x-xbitmap', 'xlb' : 'application/vnd.ms-excel', 'xls' : 'application/vnd.ms-excel', 'xlsx' : 'application/vnd.ms-excel', 'xml' : 'text/xml', 'xpdl' : 'application/xml', 'xpm' : 'image/x-xpixmap', 'xsl' : 'application/xml', 'zip' : 'application/zip' } _listeners = { \"updated\": [], \"message\": [] } /** * @prop id * @type {String} * @summary * The ID of the chat. */ id = \"\"; /** * @prop type * @type {String} * @summary * The type of the chat, options are `private` or `group`. */ type = \"\"; /** * @prop name * @type {String} * @summary * The name of the chat. For private chats, this will be name of the other user. * For a group chat, this will be a separate, unique name. */ name = \"\"; /** * @prop purpose * @type {String} * @summary * The intended purpose of the chat. Only present on groups, this will be ignored * for private chats */ purpose = \"\"; /** * @prop avatar * @type {String} * @summary * The avatar for the chat. Only present on rooms */ avatar = \"\"; /** * @prop roomNumber * @type {Number} * @summary * Room number for calling to this chat via PSTN bridge. */ roomNumber = null; /** * @prop unread * @type {Number} * @summary * Number of unread messages in this chat from the current user's perspective. */ unread = 0; /** * @prop locked * @type {Boolean} * @summary * Locked groups will block guest access, and disconnect any guests. Unlocked groups allow guests * to access the chat using the {@linkcode Chat#url} property */ locked /** * @prop pin * @type {Number} * @summary * PIN for calling to this chat via PSTN bridge, or for guest logins. */ pin = null; /** * @prop links * @type {Object[]} * @summary * List of URLs referenced in the messages of the chat. */ links = []; /** * @prop files * @type {Object[]} * @summary * List of files sent in the chat. */ files = []; /** * @prop url * @type {String} * @summary * The URL that guests can access this chat at. Only available on group chats. */ url = \"\"; /** * @prop messages * @type {ChatMessage[]} * @summary * The list of {@link ChatMessages} in this chat, in chronological order. */ messages = []; /** * @prop users * @type {User[]} * @summary * The list of {@link User Users} in this chat. */ users = []; /** * @prop created_at * @type {String} * @summary * ISO-8601 timestamp of when this chat was created. */ created_at = false; /** * @prop updated_at * @type {String} * @summary * ISO-8601 timestmap of when this chat was last modified. */ updated_at = false; /** * @prop last_seen * @type {String} * @summary * ISO-8601 timestamp of when this chat was last read, from the perspective * of the currently logged-in user. */ last_seen = false; /** * @prop last_message_time * @type {String} * @summary * ISO-8601 timestamp of when this chat received it's last message */ last_message_time = false; /** * @prop do_not_disturb * @type {Boolean} * @summary * Has this chat been set to silence notifications, from the perspective * of the currently logged-in user. */ do_not_disturb = false; /** * @prop favourite * @type {Boolean} * @summary * Has this chat been marked as a favourite, from the perspective of the * currently logged-in user. */ favourite = false; /** * @prop team * @type {Team} * @summary * ID of the Team that this chat belongs to. Needed for the `save()` method. * TODO: find a more elegant way to save this */ team = false; constructor(opts) { // Assign in passed values for (let [key, value] of Object.entries(opts)) { if (this.hasOwnProperty(key)) { // Stop using the word \"room\" if (key == \"type\" &amp;&amp; value == \"room\") value = \"group\"; // Turn the users list into real users if (key == \"users\") { value = value.map((user) =&gt; { user = new User(user) return user; }); } this[key] = value; } else { // Logger.info(\"Key not found\", key, value); } } if (this.id) { APISocket.on('chat', (chat_evt) =&gt; { let updated_evt = false; // Should this event trigger `updated` event let message_evt = false; // Should this event trigger `message` event switch (chat_evt.verb) { case \"addedTo\": if (chat_evt.attribute == \"messages\") { switch (chat_evt.added.type) { case \"chat_renamed\": this.name = chat_evt.added.body.new; updated_evt = true; break; case \"chat_locked\": this.locked = !!chat.evt.added.body; updated_evt = true; break; case \"chat_purpose\": this.purpose = chat_evt.added.body.new; updated_evt = true; break; } // If this wasn't an update, it was message, so notify listeners if (!updated_evt) message_evt = true; } break; case \"updated\": if (typeof chat_evt.data.unread !== \"undefined\") { this.unread = chat_evt.data.unread; updated_evt = true } else if (typeof chat_evt.data.last_message_time !== \"undefined\") { this.last_message_time = chat_evt.data.last_message_time; updated_evt = true } else if (typeof chat_evt.data.updatedAt !== \"undefined\") { this.updated_at = chat_evt.data.updatedAt; updated_evt = true } break; } if (updated_evt) { this._listeners.updated.map((callback) =&gt; { callback.call(this, chat_evt, this); }); } else if (message_evt) { let message = new ChatMessage(chat_evt.added) this._listeners.message.map((callback) =&gt; { this.messages.unshift(message) callback.call(this, chat_evt, this, message) }); } }); } } _onSocketMessage() { } // Try and get file extenion from the filename or mimetype _getFileExtension(fileObj) { let extension = /(?:\\.([^.]+))?$/.exec(fileObj.filename)[1]; // Try and get proper file extenion based on mimetype for (let ext in this._mimeTypes) { if(this._mimeTypes[ext] == fileObj.mimetype) extension = ext; } if (fileObj.mimetype == 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') { extension = 'xlsx'; } return extension; } /** * @static * @summary * Gets all chats that this user has access to, based on the pagination options `limit`, and `skip` * * @param {Object} opts The options for this requiest * @param {Number} [opts.limit=1000] Maximum number of chats to load * @param {Number} [opts.skip=0] Chat number to start from */ static async getAll(opts) { let options = Object.assign({}, { limit: 1000, skip: 0 }, opts); let chats = []; let chats_raw = await APISocket.get(`chat?populate=users&amp;limit=${options.limit}&amp;skip=${options.skip}`); chats_raw.map((chat_info) =&gt; { let chat = new Chat(chat_info) // Turn user list into real user obects if (chat_info.users &amp;&amp; chat_info.users.legnth &gt; 0) { chat.users = chat_info.users.map((chat_userinfo) =&gt; new User(chat_userinfo)); } chats.push(chat); }); return chats; } /** * @summary * Gets a specific chat by ID. Loads chat messages by default, but for smaller responses this can be disabled * with `opts.load_messages = false` * * @param {Object} opts The options for this request * @param {String} opts.id The ID of the chat to load * @param {Boolean} [opts.load_messages=true] `true` to load the chat message list, or `false` to disable * @param {Number} [opts.message_limit=50] Maximum number of messages to load * @param {Number} [opts.message_skip=0] Message number to start from */ static async get(opts) { let options = Object.assign({}, { id: false, load_messages: true, message_limit: 50, message_skip: 0 }, opts); if (!options.id) Logger.error(\"Chat.get requires an id\"); let querystring = \"populate=users&amp;sort=updatedAt+DESC&amp;limit=1000&amp;skip=0\" let chat_info = await APISocket.get(`chat/${options.id}?${querystring}`) if (options.load_messages === true) { let messages = await APISocket.get(`chat/${options.id}/messages?populate=file&amp;populate=user_mentions&amp;limit=${options.message_limit}&amp;skip=${options.message_skip}`); messages = messages.sort(function(a, b) { if (new Date(a) &lt; new Date(b)) { return 1; } else if (new Date(a) &gt; new Date(b)) { return -1; } else if (new Date(a) == new Date(b)) { return 0; } }); messages.map((message_data) =&gt; { chat_info.messages.push(new ChatMessage(message_data)); }) } return new Chat(chat_info); } /** * @static * @async * @summary * Saves a chat object by attempting to commit any dirty fields to the appropriate API endpoints. If the chat * has an `id` and `created_at` date, then it will attempt to save the information. If those fields are unset, then the chat is assumed to be new and is created instead. */ async save(opts) { let options = Object.assign({}, { }, opts); if (this.created_at &amp;&amp; this.id) { console.log(\"Existing chat\"); } else { console.log(\"No created_at, creating new\"); // This is a totally new chat let type = (this.type == \"group\") ? \"room\" : this.type; let chat_info = await APISocket.post(`chat/`, { name: this.name, type: type, purpose: this.purpose, team: this.team, users: this.users }) console.log(\"Creating a chat returned\", chat_info); return new Chat(chat_info); } } /** * @async * @summary * Enables guest access on this chat by generating a new {@link Chat#pin PIN}, and invalidate any existing guest sessions. */ async generateGuestURL(opts) { let options = Object.assign({}, { }, opts); let guest_response = await APISocket.get(`chat/${this.id}/generateUrl`) if (guest_response.constructor.name == \"Array\") { return new Chat(guest_response[0]); } else { return new Chat(guest_response); } } /** * @async * @summary * Sends a chat message. * * @description * Sends a text message to a chat, and then triggers the `.on('message')` listeners with the content of the new message. * * @param {String} message The message to send */ async sendMessage(message) { if (!message || typeof message != \"string\") return; if (!this.id) return; let message_props = { type: \"text\", body: message } let result = APISocket.post(`chat/${this.id}/messages`, message_props) let msg_object = new ChatMessage(Object.assign(message_props, { from: APISocket.current_user, chat: this, created_at: new Date().toString() })); this._listeners.message.map((callback) =&gt; { this.messages.unshift(msg_object) callback.call(this, {}, this, msg_object); }); return new Promise((resolve, reject) =&gt; { resolve(msg_object); }); } /** * @async * @summary * Sends a file * * @param {Object} fileObj The file to send */ async sendFile(fileObj) { if (!fileObj) return; if (!this.id) return; // Request data let message_props = { type: \"filestack\", chat_id: this.id, body: fileObj } message_props.body.extension = this._getFileExtension(fileObj); let result = APISocket.post(`chat/${this.id}/messages`, message_props) let msg_object = new ChatMessage(Object.assign(message_props, { from: APISocket.current_user, chat: this, created_at: new Date().toString() })); this._listeners.message.map((callback) =&gt; { this.messages.unshift(msg_object) callback.call(this, {}, this, msg_object); }); return new Promise((resolve, reject) =&gt; { resolve(msg_object); }); } /** * @summary * Adds user(s) to a chat * * @param {User[]} users The user(s) to add. Either supply a single User object, or * an array of Users to add each. * * @returns {Chat} Successfully adding will return `true` */ async addUser(users) { let add_response; if (typeof users === \"object\" &amp;&amp; users.constructor.name === \"User\") { try { add_response = await APISocket.post(`chat/${this.id}/users`, { user: users.id }) } catch (err) { throw new Error(err); return false; } } else if (Array.isArray(users)) { return users.map(async (user) =&gt; { try { add_response = await APISocket.post(`chat/${this.id}/users`, { user }) } catch (err) { throw new Error(err); return false; } }) } else { throw new Error(\"Chat.addUser only accepts User object(s), recieved\", typeof users); } } /** * @summary * Remoevs user(s) from a chat * * @param {User[]} users The user(s) to remove. Either supply a single User object, * or an array of Users to delete each. * * @returns {Chat} Successfully deleting will return `true` */ async removeUser(users) { let add_response; if (typeof users === \"object\" &amp;&amp; users.constructor.name === \"User\") { try { add_response = await APISocket.delete(`chat/${this.id}/users/${users.id}`) } catch (err) { throw new Error(err); return false; } } else if (Array.isArray(users)) { return users.map(async (user) =&gt; { try { add_response = await APISocket.post(`chat/${this.id}/users/${user}`) } catch (err) { throw new Error(err); return false; } }) } else { throw new Error(\"Chat.addUser only accepts User object(s), recieved\", typeof users); } } /** * @summary * Invite guest(s) to join a group chat. * * @description * Guests can only be added to chats with the {@link Chat#type `type`} of group, can only access the chat they're added to, and will be removed if {@link Chat#generateGuestURL `generateGuestURL`} is called again. * * @param {String|Array} emails Either a single email address, or an array of email addresses to send guest invites to * * @returns {Promise} Promise that will be resolved with the result of the invite, or rejected with the error as the first argument. * * @example * Chat.get({ id: \"abc123\" }) * .then((chat) =&gt; { * // Send one invite * chat.inviteGuest(\"myguest1@example.com\") * * // Send multiple invites * chat.inviteGuest([\"myguest2@example.com\", \"myguest3@example.com\"]); * }) */ async inviteGuest(emails = []) { if (!emails) throw Error(\"Chat.inviteGuest requires a list of emails\"); if (!Array.isArray(emails) &amp;&amp; typeof emails != 'string') throw TypeError(\"Chat.inviteGuest requires an array or string, received\", typeof emails); // User supplied a string; make an array for them if (!Array.isArray(emails)) emails = [emails]; let add_response; // Check to see if the owner already exists for (let i = 0; i &lt; emails.length; i++) { let guest_exists; try { guest_exists = await Guest.exists({ email: emails[i], team: this.team }) } catch (err) { throw Error(err); } if (guest_exists) throw Error(`Chat.inviteGuest can't invite existing guests, ${emails[i]} is already in use`); } try { add_response = await APISocket.post(`guest/invite`, { chat: this.id, emails }) } catch (err) { throw new Error(err); } if ( typeof add_response == \"object\" &amp;&amp; Array.isArray(add_response) &amp;&amp; add_response.length &gt; 0 ) { return add_response; } else { throw new Error(\"Problem inviting guest, received\", add_response) } } /** * @summary * Marks a chat as read by updating the {@linkcode Chat#last_seen last_seen} with the current time. * * @description * This can be any chat that the user has access to. The original chat will be updated * in-place with any successfully applied values, and a copy will also be passed into the * promise. * * @returns {Promise} Promise that will resolve with the updated Chat as the first argument, * or rejected with the error as the first argument */ async markAsRead() { let read_res; try { read_res = await APISocket.post(`chat/${this.id}/seen`); } catch (err) { throw Error(err); } if (read_res &amp;&amp; typeof read_res[0] == \"object\") { for (let [key, value] of Object.entries(read_res[0])) { if (this.hasOwnProperty(key)) this[key] = value; } } else { throw Error(\"markAsRead failed, response\", read_res); } return this; } /** * @summary * Deletes a chat * * @returns {Promise} Promise that will resolve with the server response as the first argument if * the chat is deleted, or rejected with the error as the first argument * * @example * let myChat = await Chat.get({ id: \"abc123\" }); * if (window.confirm('delete this chat?')) { * myChat.delete() * } */ async delete() { let delete_res; try { delete_res = await APISocket.delete(`chat/${this.id}`); } catch (err) { throw Error(err); } return delete_res; } /** * @summary * Listen for changes to this chat coming in over the APISocket. * * @description * | Event | Description | * | --- | --- | * | `updated` | Chat information has changed. Callback will be called with the signature `callback(evt, chat)` with `evt` being the original socket event, and `chat` is the updated Chat object. This happens when a user changes the `purpose`, `locked`, or `name`. | * | `message` | New message to this chat, from someone else or from the current user. Callback will be called with the signature `callback(evt, chat, message)` with `evt` being the original socket event, `chat` is the Chat object with the new message inserted in `messages`, and `message` is the {@link ChatMessage} that was sent. | * * @param {String} evt The event to listen for * @param {function} callback The callback to fire when the event occurs */ on(evt, callback) { if (!this.id) return; if (!evt || !this._listeners.hasOwnProperty(evt)) return; if (!callback || typeof callback != \"function\") return; this._listeners[evt].push(callback); } /** * @summary * Converts a chat to an HTML fragment for debugging purposes. * * @example * document.getElementById(\"chat_debug\").innerHTML = my_chat.toHTML(); */ toHTML() { let name, second_line, messages; if (this.type == \"private\") { let other_user = Skrumble.removeSelf(this.users); name = `${other_user.first_name} ${other_user.last_name}` second_line = \"\" } else { name = this.name; second_line = this.purpose; } if (this.messages.length) { messages = this.messages.reduce(function(acc, msg) { acc = (typeof acc == \"object\") ? `${acc.toHTML()}&lt;br /&gt;\\n` : acc; return `${acc} ${msg.toHTML()}&lt;br /&gt;\\n`; }) } return ` &lt;header&gt; &lt;h1&gt;${name}&lt;/h1&gt; &lt;p&gt;${second_line}&lt;/p&gt; &lt;/header&gt; ${messages}`; } } × Search results Close "},"ChatMessage.js.html":{"id":"ChatMessage.js.html","title":"Source: ChatMessage.js","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams Source: ChatMessage.js import { APISocket } from \"./APISocket\"; import { Logger } from \"./Logger\"; import { User } from \"./User\"; import { Guest } from \"./Guest\"; /** * @class * @hideconstructor * @classdesc * ChatMessages describe individual messages inside a {@link Chat}. This can be simple messages like * text or files, or events like a user joining a group. For more information about the various types * of ChatMessages and how to handle them, see {@link ChatMessage#type `type`}. */ export class ChatMessage { constructor(opts) { /** * @prop type * @type {String} * @summary * The type of event this message is for. * * @description * ChatMessages don't just represent traditional text messages or files, but also several different types of notifications about the chat itself. Options are: * * | Type | Description | * | --- | --- | * | `text` | This is a text chat message, with the content in {@link ChatMessage#body `body`}. | * | `file` | A file message with the properties of the file on the {@link ChatMessage#file `file`} property. | * | `call_log` | A record of a call with this chat. Call logs for groups will have the `body.type` of `conference_started` (starting a call), `conference_ended` (call ended), `conference_join` (user joining call), or `conference_leave` (user leaving call). Private chats will have the `body.type` of `missed` or `call` (which will have `body.duration` with the duration of the call in seconds). | * | `voicemail` | A voicemail left by another user in a private chat. The {@link ChatMessage#file `file`} field will be a wav file of the message | * | `chat_renamed` | Group chat only. The `name` of this chat was changed. The `body` will be an object: `{ 'new': 'group new name', 'old': 'group previous name' }` | * | `chat_purpose` | Group chat only. The `purpose` of this chat was changed. The `body` will be an object: `{ 'new': 'group new purpose', 'old': 'group prev purpose' }` | * | `chat_locked` | Group chat only. A user has locked/unlocked a group. The `body` will be `1` if the group was locked, and `0` if it was unlocked | * | `participant_added` | Group chat only. User(s) have been added to the chat. The `body` will be an array of users that have been added. | * | `participant_removed` | Group chat only. User(s) have been removed from the chat. The `body` will be an array of users that have been removed. | * | `recording_video` | The recording of a group conference, along with an optional transcript. The attached file is the recording. | */ this.type = \"\" /** * @prop body * @type {String} * @summary * The content of the message. */ this.body = \"\" /** * @prop file * @type {Object} * @summary * Files attached to this message, or `false`. * * @description * For messages with a {@link ChatMessage#type `type`} of `file`, `recording_video`, or `voicemail`, this will be the information about the file. Messages of other types will have this set to `false`. * * | Property | Description | * | -------- | ----------- | * | `url` | Public URL to download this file | * | `created_at` | ISO 8601 string of the time the file was created | * | `name` | Full uploaded path and filename | * | `size` | Filesize in bytes | * | `filename` | Filename only | * | `thumb_url` | Thumbnail URL, for `png`, `jpg`, and `gif` files only | * | `thumbHeight` | Height in px of the thumbnail | * | `thumbWidth` | Width in px of the thumbnail | */ this.file = false; /** * @prop chat * @type {String} * @summary * The ID of the Chat this belongs to */ this.chat = \"\" /** * @prop created_at * @type {String} * @summary * The ISO 8601 string representing the time this message was created on the server */ this.created_at = \"\" /** * @prop from * @type {(User|Guest)} * @summary * Who this message was sent by. */ this.from = \"\" /** * @prop id * @type {String} * @summary * The unique ID of this message. */ this.id = \"\" /** * @prop language * @type {String} * @summary * The language this message was sent in. */ this.language = \"\" /** * @prop links * @type {String[]} * @summary * An array of URLs in this message. */ this.links = [] /** * @prop room_mentions * @type {Array} * @summary * An array of mentions to chats in this message. */ this.room_mentions = [] /** * @prop user_mentions * @type {Array} * @summary * An array of mentions to users in this message */ this.user_mentions = [] // Assign in passed values for(let [key, value] of Object.entries(opts)) { if (this.hasOwnProperty(key)) { if (key == \"from\" &amp;&amp; value.role) { if (value.role !== \"guest\") value = new User(value); if (value.role === \"guest\") value = new Guest(value); } // Convert user mentions to real user objects if (key == \"user_mentions\" &amp;&amp; Array.isArray(value) &amp;&amp; value.length &gt; 0) { value.map((user_mention) =&gt; { if (user_mention.role !== \"guest\") return new User(user_mention); if (user_mention.role === \"guest\") return new Guest(user_mention); }); } // Convert group mentions to real chat objects if (key == \"group_mentions\" &amp;&amp; Array.isArray(value) &amp;&amp; value.length &gt; 0) { value.map((group_mention) =&gt; new Chat(group_mention)); } this[key] = value; } else { // Logger.info(\"Key not found\", key, value); } } } /** * @summary * Translates a message and returns the translation. * * @description * Languages for the translation are automatic and based on the `language` property of the user sending the message, and the user performing the translation. For example, if a user with the `language` of `es` sends a message, and the current user has a language of `fr`, then this will attempt to translate from Spanish to French. This will only work on messages with the `type` of `text` * @see {@linkcode User#language User.language} * * @returns {Promise} Promise that will resolve with the translation as the first argument * * @example * ChatMessage.translate() * .then((translation) =&gt; { * console.log(translation); * }) */ async translate() { if (!this.id) throw TypeError(\"ChatMessage.translate can only be called on a ChatMessage with an id\"); if (!this.chat) throw TypeError(\"ChatMessage.translate can only be called on a ChatMessage with an associated chat\"); if (this.type !== 'text') throw TypeError(\"ChatMessage.translate can only be called on ChatMessages with the type of 'text'\"); let translate_res; try { translate_res = await APISocket.get(`chat/${this.chat}/messages/${this.id}/translate`) } catch (err) { throw Error(err); } return translate_res; } /** * @summary * Converts a chat to an HTML fragment for debugging purposes. * * @example * document.getElementById(\"chat_msg_debug\") = chat_message.toHTML(); */ toHTML() { var date = new Date(this.created_at).toLocaleString(); var message = `&lt;em&gt;(${date})&lt;/em&gt; &lt;strong&gt;${this.from.first_name} ${this.from.last_name}&lt;/strong&gt;`; switch (this.type) { case \"text\": this.body = (\"\" + this.body).replace(/((http|https|ftp):\\/\\/[\\w?=&amp;.\\/-;#~%-]+(?![\\w\\s?&amp;.\\/;#~%\"=-]*&gt;))/g, '&lt;a href=\"$1\" target=\"_blank\"&gt;$1&lt;/a&gt;') message += `: ${this.body}`; break; case \"call_log\": switch (this.body.type) { case \"conference_started\": message += ` started a call`; break; case \"conference_ended\": message += ` ended the call`; break; case \"conference_join\": message += ` joined the call`; break; case \"conference_leave\": message += ` left the call`; break; case \"missed\": message += ` called &lt;strong&gt;${this.body.to.first_name} ${this.body.to.last_name}&lt;/strong&gt; (missed)` break; case \"call\": message += ` called &lt;strong&gt;${this.body.to.first_name} ${this.body.to.last_name}&lt;/strong&gt; &lt;em&gt;(${this.body.duration}s)&lt;/em&gt;` break; default: // debugger; } break; case \"participant_added\": message += \" joined the conversation\"; break; case \"participant_removed\": message += \" left the conversation\"; break; case \"chat_locked\": if (!!this.body) { message += \" locked the conversation\"; } else { message += \" unlocked the conversation\"; } break; case \"chat_purpose\": message += ` changed the purpose from &lt;em&gt;${this.body.old}&lt;/em&gt; to &lt;em&gt;${this.body.new}&lt;/em&gt;`; break; case \"chat_renamed\": message += ` renamed the conversation from &lt;em&gt;${this.body.old}&lt;/em&gt; to &lt;em&gt;${this.body.new}&lt;/em&gt;`; break; case \"voicemail\": message += ` left a voicemail [&lt;a href=\"${this.file.url}\" target=\"_blank\"&gt;link&lt;/a&gt;]`; break; case \"file\": message += ` sent &lt;em&gt;${this.file.filename}&lt;/em&gt; [&lt;a href=\"${this.file.url}\" target=\"_blank\"&gt;link&lt;/a&gt;]`; break; case \"recording_video\": message += ` made a recording [&lt;a href=\"${this.file.url}\" target=\"_blank\"&gt;link&lt;/a&gt;]`; break; case \"room\": message = \"\"; break; default: // debugger; message = \"\"; break; } return message; } } × Search results Close "},"Guest.js.html":{"id":"Guest.js.html","title":"Source: Guest.js","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams Source: Guest.js import { Logger } from \"./Logger\" import { APISocket } from './APISocket'; import axios from 'axios'; /** * @class * @hideconstructor * @classdesc * Guests are temporary users that are granted access to one group {@link Chat} using the chat's {@link Chat#guest_url guest URL}. */ export class Guest { constructor(options) { /** * @readonly * @prop id * @type {String} * @summary * The ID of the user, assigned by the API * */ this.id = \"\" /** * @prop first_name * @type {String} * @summary * The first name of the guest. */ this.first_name = \"\" /** * @prop last_name * @type {String} * @summary * The last name of the guest. */ this.last_name = \"\" /** * @prop avatar * @type {String} * @summary * The URL of the guest's avatar. */ this.avatar = \"\" /** * @prop email * @type {String} * @summary * The email address of the guest. */ this.email = \"\" /** * @prop chat_id * @type {String} * @summary * The {@link Chat#id Chat ID} this guest is valid for. */ this.chat_id = \"\" /* * @prop extensionSecret * @type {String} * @summray * The user's password for SIP phone registration. */ this.extension_secret = \"\"; /** * @prop role * @type {String} * @summary * The user's role on the team, possibilities are `admin` or `member` */ this.role = \"\" /** * @readonly * @prop teams * @type {Team[]} * @summary * A list of teams this user is on */ this.teams = [] /** * @prop caller_id_name * @type {String} * @summary * When making outbound calls, this will be the name field of the Caller ID, visible to the other caller. If this is blank * (default), the name will default to {@linkcode Team#caller_id_name Team.caller_id_name}. */ this.caller_id_name = \"\" /** * @prop caller_id_number * @type {String} * @summary * When making outbound calls, this will be the number field of the Caller ID, visible to the other caller. If this is blank (default), the name will default to {@linkcode Team#caller_id_number Team.caller_id_number}. */ this.caller_id_number = \"\" // Assign in passed values for(let [key, value] of Object.entries(options)) { if (this.hasOwnProperty(key)) { this[key] = value; } else { // Logger.info(\"Key not found in Guest\", key, value); } } } /** * @summary * Check if a guest exists on a given team. * * @description * Guests are unique to each team, so a Team or TeamID must also be supplied, and can only * be called after logging-in. This is called automatically by {@link Chat#inviteGuest `Chat.inviteGuest()`}. * * @param {Object} opts Options for this request * @param {String} opts.email Email of the guest to look for * @param {Team|String} opts.team The team to look for this guest in. Either a Team object or a Team ID * * @returns {Promise} Promise that will resolve with a boolean representing if a team with that name exists or not, or rejected with the error as the first argument * * @example * Guest.exists({ email: \"guestuser@example.com\", team: myTeam }) * .then((guestExists) =&gt; console.log(guestExists ? 'guest exists!' : 'no guest with that email')) * .catch((err) =&gt; console.error(err)) */ static async exists(opts) { let options = Object.assign({}, { email: '', team: '', }, opts); let exists_res; let response_code; if (!options.email) throw Error('Guest.exists requires an email (opts.email)'); if (!options.team) throw Error('Guest.exists requires a Team object or a team ID (opts.team)'); if (typeof options.email != \"string\") throw TypeError(\"Guest.exists email must be a string, received\", typeof options.email) if (typeof options.team != \"string\" &amp;&amp; options.team.constructor.name != \"Team\") { throw TypeError(\"Guest.exists team must be either a team ID or a Team object, received\", typeof options.team); } // If user passed a Team object, pull the ID from that if (options.team.constructor.name == \"Team\") options.team = options.team.id try { exists_res = await APISocket.post(`team/${options.team}/guest/exists`, { emails: [options.email] }); } catch(err) { return new Error(err); } if ( typeof exists_res == \"object\" &amp;&amp; Object.prototype.hasOwnProperty.call(exists_res, 'existing') ) { return !!exists_res.existing.length; } } } × Search results Close "},"Logger.js.html":{"id":"Logger.js.html","title":"Source: Logger.js","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams Source: Logger.js export const LOG_LEVEL = { ALL: 9, INFO: 3, WARN: 2, ERROR: 1, NONE: 0 }; // Default to logging everything let log_level = LOG_LEVEL.ALL; /** * @class * @hideconstructor */ export class Logger { /** * @summary * Print something to the console as a message */ static log(...items) { if (log_level &gt;= LOG_LEVEL.INFO) { console.log.apply(this, items); } } /** * @summary * Print something to the console as an info message */ static info(...items) { if (log_level &gt;= LOG_LEVEL.INFO) { console.info.apply(this, items); } } /** * @summary * Print something to the console as a warning */ static warn(...items) { if (log_level &gt;= LOG_LEVEL.WARN) { console.warn.apply(this, items); } } /** * @summary * Print something to the console as an error */ static error(...items) { if (log_level &gt;= LOG_LEVEL.ERROR) { console.error.apply(this, items); } } /** * @summary * Sets the logging level */ static setLogLevel(level) { log_level = level; } } × Search results Close "},"Team.js.html":{"id":"Team.js.html","title":"Source: Team.js","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams Source: Team.js import { APISocket } from \"./APISocket\"; import { Logger } from \"./Logger\"; import { User } from \"./User\"; import axios from 'axios'; /** * Fields that can be edited after creating a team * * @ignore */ let editable_fields = [ 'team_name', 'country', 'city', 'state', 'address_1', 'address_2', 'postal', 'timezone', 'caller_id_name', 'caller_id_number', ]; /** * @class * @hideconstructor * @classdesc * The settings and info for a team. * */ export class Team { constructor(opts) { /** * @prop id * @type {String} * @summary * Unique ID of the team. */ this.id = \"\"; /** * @prop owner * @type {User} * @summary * The User that created this team. */ this.owner = false; /** * @prop team_name * @type {String} * @summary * Display name of the team. */ this.team_name = \"\"; /** * @prop team_avatar * @type {String} * @summary * The URL of the team's avatar. */ this.team_avatar = \"\"; /** * @prop slug * @type {String} * @summary * Team name with special characters removed. Used to create URL-friendly guest links. */ this.slug = \"\"; /** * @prop country * @type {String} * @summary * Team's country. */ this.country = \"\"; /** * @prop city * @type {String} * @summary * Team's city. */ this.city = \"\"; /** * @prop state * @type {String} * @summary * Team's province or state */ this.state = \"\"; /** * @prop address_1 * @type {String} * @summary * Team's address line 1 */ this.address_1 = \"\"; /** * @prop address_2 * @type {String} * @summary * Team's address line 2 */ this.address_2 = \"\"; /** * @prop postal * @type {String} * @summary * Team's postal or zip code */ this.postal = \"\"; /** * @prop timzeon * @type {String} * @summary * The TZ string of this team's timezone */ this.timezone = \"\"; /** * @prop autoreception * @type {String} * @summary * What point of setting-up autoreception is complete. Options are `completed` @todo */ this.autoreception = \"\"; /** * @prop caller_id_name * @type {String} * @summary * The default caller ID name field for all members. * * @see {@link User#caller_id_name} */ this.caller_id_name = \"\"; /** * @prop caller_id_number * @type {String} * @summary * The default caller ID number field for all members. * * @see {@link User#caller_id_number} */ this.caller_id_number = \"\"; for (let [key, value] of Object.entries(opts)) { if (this.hasOwnProperty(key)) { this[key] = value; } else { // Logger.info(\"Key not found\", key, value); } } } /** * Loads a team by ID * * @param {Object} opts Options for the request * @param {String} opts.id The ID of the team to load */ static async get(opts) { var options = Object.assign({}, { id: false }, opts); var team = await APISocket.get(`team/${options.id}?populate=departments&amp;users=true`) return new Team(team); } /** * @summary * Creates a team * * @description * Creates a team by first creating an Owner account, who is the first user * on the team. Then creates the team and assigns the Owner to it. NB: Team names are unique * * @param {Object} opts Options for the request * @param {String} opts.owner_first_name Owner's first name * @param {String} opts.owner_last_name Owner's last name * @param {String} opts.owner_email Owner's email. Used later for authentication and cannot be changed. * @param {String} opts.owner_password Owner's password * @param {String} opts.name Name of the team * @param {String} opts.country Team country * @param {String} opts.city Team city * @param {String} opts.state Team state * @param {String} [opts.referral_code] Referral code, if any * * @returns {Promise} Promise that will resolve with the newly created team if the team creation was successful, and be rejected with an error as the first argument if the attempt fails * * @example * let owner_email = \"owner@example.com\"; * let owner_password = \"hunter2\"; * * Team.create({ * owner_first_name: \"jane\", * owner_last_name: \"doe\", * owner_email, * owner_password, * name: \"My SDK Team\", * country: \"Canada\", * city: \"Toronto\", * state: \"ON\" * }) * .then((newTeam) =&gt; { * console.log(\"new team created\", newTeam); * * // You can log-in now as the owner * APISocket.login({ * email: owner_email, * password: owner_password * }) * }) * .catch((err) =&gt; console.error(\"team creation err\", err)) */ static async create(opts) { var options = Object.assign({}, { owner_first_name: \"\", owner_last_name: \"\", owner_email: \"\", owner_password: \"\", name: \"\", country: \"\", city: \"\", state: \"\", referral_code: \"\" }, opts); let team_exists; let owner_exists; let owner_res; let team_res; // Check for required fields if (!options.owner_first_name) throw Error(\"Team.create requires an owner first name (opts.owner_first_name)\"); if (!options.owner_last_name) throw Error(\"Team.create requires an owner last name (opts.owner_last_name)\"); if (!options.owner_email) throw Error(\"Team.create requires an owner email (opts.owner_email)\"); if (!options.owner_password) throw Error(\"Team.create requires an owner password (opts.owner_password)\"); if (!options.name) throw Error(\"Team.create requires a team name (opts.name)\"); if (!options.country) throw Error(\"Team.create requires a team country (opts.country)\"); if (!options.city) throw Error(\"Team.create requires a team city (opts.city)\"); if (!options.state) throw Error(\"Team.create requires a team state (opts.state)\"); // Type-check fields if (typeof options.owner_first_name !== \"string\") throw TypeError(`Team.create owner_first_name must be a string, received ${typeof options.owner_first_name}`); if (typeof options.owner_last_name !== \"string\") throw TypeError(`Team.create owner_last_name must be a string, received ${typeof options.owner_last_name}`); if (typeof options.owner_email !== \"string\") throw TypeError(`Team.create owner_email must be a string, received ${typeof options.owner_email}`); if (typeof options.owner_password !== \"string\") throw TypeError(`Team.create owner_email must be a string, received ${typeof options.owner_email}`); if (typeof options.name !== \"string\") throw TypeError(`Team.create name must be a string, received ${typeof options.name}`); if (typeof options.country !== \"string\") throw TypeError(`Team.create country must be a string, received ${typeof options.country}`); if (typeof options.city !== \"string\") throw TypeError(`Team.create city must be a string, received ${typeof options.city}`); if (typeof options.state !== \"string\") throw TypeError(`Team.create state must be a string, received ${typeof options.state}`); // Check to see if the team already exists try { team_exists = await Team.exists(options.name) } catch (err) { throw Error(err); } if (team_exists) throw Error(`Team.create can't use an existing team name, ${options.name} is already in use`) // Check to see if the owner already exists try { owner_exists = await User.exists(options.owner_email) } catch (err) { throw Error(err); } if (owner_exists) { throw Error(`Team.create can't use an existing owner, ${options.owner_email} is already in use`); } else { // First create the team owner try { owner_res = await axios.post(`${APISocket.api_url}/v3/user`, { first_name: options.owner_first_name, last_name: options.owner_last_name, email: options.owner_email, password: options.owner_password, }); } catch(err) { throw Error(err); } // If the owner was created, create the team if (parseInt(owner_res.status, 10) === 201) { try { team_res = await axios.post(`${APISocket.api_url}/v3/team`, { team_name: options.name, owner: owner_res.data.id, country: options.country, city: options.city, state: options.state, ref: options.referral_code, }); } catch(err) { throw Error(err); } if (parseInt(team_res.status, 10) === 201) { return new Team(team_res.data); } else { throw Error(`Team.create failed to create a Team. Error ${team_res.status}: ${team_res.statusText}`) } } else { // Owner wasn't created properly throw Error(`Team.create failed to create a Team owner. Error ${owner_res.status}: ${owner_res.statusText}`) } } } /** * @summary * Admin-only: save any changed information about a Team. The original team object will be modified in-place * with whatever values are applied successfully, and a copy will be passed into the promise. * * @returns {Promise} Promise that will resolve with the updated Team as the first argument, or rejected with the error as the first argument * * @example * let me = await APISocket.login({ ...opts }) * let myTeam = me.teams[0]; * * myTeam.team_name = \"New team name\"; * myTeam.city = \"Toronto\"; * myTeam.save() * .then((myTeam) =&gt; console.log(\"Updated myTeam\", myTeam)) * .catch((err) =&gt; console.error(\"Team save error\", err)) */ async save() { let save_res; if (!this.id) throw Error(\"Team.save must be run on a User object with an ID\"); // Only send the params this request that can be edited let request_options = _.pick(this, editable_fields); // Send updated values to API try { save_res = await APISocket.patch(`team/${this.id}`, request_options); } catch (err) { throw Error(err); } // Assign in passed values if (save_res) { for (let [key, value] of Object.entries(save_res)) { if (this.hasOwnProperty(key)) this[key] = value; } } return this; } /** * @summary * Check if a team exists, in order to create one safely. This is called automatically during Team.create() * * @param {String} team_name Team name to check the existence of * @returns {Promise} Promise that will resolve with a boolean representing if a team with that name exists or not, or rejected with the error as the first argument * * @example * Team.exists(\"My team name\") * .then((teamExists) =&gt; console.log(teamExists ? 'team exists!' : 'no team with that name')) * .catch((err) =&gt; console.error(err)) */ static async exists(team_name = \"\") { let exists_res; let response_code; if (!team_name) Logger.error(\"Team.exists requires a team name\"); if (typeof team_name !== \"string\") throw TypeError(`Team.exists team name must be a string, received ${typeof team_name}`); try { exists_res = await axios.post(`${APISocket.api_url}/v3/team/exist`, { team_name }); } catch(err) { return new Error(err); } response_code = parseInt(exists_res.status, 10); if (Math.floor(response_code / 100) === 2) { if ( typeof exists_res.data == \"object\" &amp;&amp; Object.prototype.hasOwnProperty.call(exists_res.data, 'exists') ) { return !!exists_res.data.exists; } } else { return false; } } } × Search results Close "},"User.js.html":{"id":"User.js.html","title":"Source: User.js","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams Source: User.js import { APISocket } from \"./APISocket\"; import { Logger } from \"./Logger\"; import axios from 'axios'; import _ from 'lodash'; /** * Fields that can be edited after creating a user * * @ignore */ let editable_fields = [ 'first_name', 'last_name', 'position', 'caller_id_name', 'caller_id_number', 'avatar', 'dateformat', 'forward', 'forward_number', 'home_number', 'mobile_number', 'language', 'latitude', 'longitude', 'password', 'state', 'status', 'theme', 'timeformat', 'timezone', 'tooltips', 'voicemail', 'website', 'work_number' ]; /** * @class * @hideconstructor * @classdesc * The User class allows read access to user information. It's also possible to update User information with {@link User#save `save()`} if the User you're editing is yourself, or * if you're logged-in as an Admin. Static methods like {@link User#get `get()`} or {@link User#create `create()`} won't work on User instances, but will retrieve or create * User objects respectively. Users will emit socket events when information about them is modified * * @summary * A Skrumble Team Member. * * * @example * var workingUser = User.create({ * email: \"user@example.com\", // Required * plan: \"pro\", // Required * first_name: \"Test\", // Required, minlength: 2 * last_name: \"User\", // Required, minlength: 2 * password: \"Password1\", // Required, minlength: 8 * team: \"abc123\" // Required * }) * * // Persist changes * workingUser.position = \"CEO\"; * workingUser.save(); * * @see {@linkcode User.create} * @see {@linkcode User.invite} */ export class User { /** * @readonly * @prop id * @type {String} * @summary * The ID of the user, assigned by the API * */ id = \"\" /** * @prop first_name * @type {String} * @summary * The first name of the user */ first_name = \"\" /** * @prop last_name * @type {String} * @summary * The last name of the user */ last_name = \"\" /** * @prop position * @type {String} * @summary * Position in the team */ position = \"\" /** * @prop email * @type {String} * @summary * Email address. */ email = \"\" /** * @prop password * @type {String} * @summary * User password in plain text. */ password = \"\" /** * @prop avatar * @type {String} * @summary * URL to the user's avatar */ avatar = \"\" /** * @prop state * @type {String} * @summary * The state of the user, the options are `online` or * `offline` */ state = \"\" /** * @prop status * @type {String} * @summary * The call availability of this user */ status = \"\" /** * @prop role * @type {String} * @summary * The user's role on the team, possibilities are `admin` or `member` */ role = \"\" /** * @prop plan * @type {String} * @summary * The user's subscription type, either the Pro or Unlimited packages currently */ plan = \"\" /** * @prop language * @type {String} * @summary * The user's preferred language. * * @description * Used for comparison when calling {@link ChatMessage#translate `ChatMessage.translate`}. Also used * by official Skrumble clients to determine interface language. * * @see [List of ISO-639-1 codes - Wikipedia]{@link https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes} */ language = \"en\" /** * @prop timezone * @type {String} * @summary * The TZ string value of the user's timezone */ timezone = \"\" /** * @prop timeformat * @type {String} * @summary * The user's preferred formatting of time values: `12-hour` or `24-hour` */ timeformat = \"\" /** * @prop dateformat * @type {String} * @summary * The formatting of dates */ dateformat = \"\" /** * @prop tooltips * @type {Boolean} * @summary * `true` if the user has requested UI tooltips for help on app.skrumble.com, `false` if disabled. */ tooltips = false /** * @prop created_at * @type {String} * @readonly * @summary * The datetime a user was created in ISO 8601 */ created_at = \"\" /** * @prop extension * @type {String[]} * @summary. * The list of extensions this user can be called at, based on their {@link CallRoute CallRoutes}. */ extension = [] /* * @prop extensionSecret * @type {String} * @summray * The user's password for SIP phone registration. */ extension_secret = \"\"; /** * @readonly * @prop teams * @type {Team[]} * @summary * A list of teams this user is on */ teams = [] /** * @prop voicemail * @type {boolean} * @summary * Is voicemail enabled for this user or not. If `true`, then calls that go unanswered after 30s will be * redirected to the user's voicemail box. `false` will disable voicemail entirely and missed calls will simply end. */ voicemail = true /** * @prop forward * @type {Boolean} * @summary * The user's call forwarding setting. `true` will forward all inbound calls to {@linkcode User#forward_number User.forward_number} and `false` will recieve calls normally */ forward = false /** * @prop forward_number * @type {Dialstring} * @summary * If {@link User#forward `User.forward`} is enabled, this will set where inbound calls are directed to */ forward_number = \"\" /** * @prop caller_id_name * @type {String} * @summary * When making outbound calls, this will be the name field of the Caller ID, visible to the other caller. If this is blank * (default), the name will default to {@linkcode Team#caller_id_name Team.caller_id_name}. */ caller_id_name = \"\" /** * @prop caller_id_number * @type {String} * @summary * When making outbound calls, this will be the number field of the Caller ID, visible to the other caller. If this is blank (default), the name will default to {@linkcode Team#caller_id_number Team.caller_id_number}. */ caller_id_number = \"\" /** * @prop work_number * @type {Dialstring} * @summary * The work number the user has entered in their profile. */ work_number = \"\" /** * @prop home_number * @type {Dialstring} * @summary * The home number the user has entered in their profile. */ home_number = \"\" /** * @prop mobile_number * @type {Dialstring} * @summary * The mobile number the user has entered in their profile. */ mobile_number = \"\" /** * @prop website * @type {String} * @summary * The website the user has entered in their profile. This should be a valid URL. */ website = \"\" /** * @prop latitude * @type {String} * @summary * The user's last recorded latitude. */ latitude = \"\" /** * @prop longitude * @type {String} * @summary * The user's last recorded longitude */ longitude = \"\" /** * @prop theme * @type {String} * @summary * The user's preferrerd desktop theme, the options are `dark` and `light`. New users wll default to `dark`. */ theme = \"dark\" /** * @prop accepted * @type {String} * @summary * The ISO8601 datestamp of when the user accepted the invitation to join the team. If the user was created and not invited, then this will be equal to the user's {@linkcode User#created_at created_at}. */ accepted = \"\" /** * @prop last_login * @type {String} * @summary * The ISO8601 datestamp of when this user last logged-in */ last_login = \"\" /** * @prop deleted_at * @type {String} * @summary * The ISO8601 datestamp of when this user was deactivated. Deactivated users cannot send or recieve chat messages or calls, and won't appear in chat participant lists or lists of users */ deleted_at = \"\" constructor(options) { // Assign in passed values for (let [key, value] of Object.entries(options)) { if (this.hasOwnProperty(key)) { this[key] = value; } else { // Logger.info(\"Key not found in User\", key, value); } } } /** * @summary * Saves the details of a given user by sending a PATCH request. * * @description * For admins, this can be the information of any team member. For regular * users, it can only be their own information, or the API will return an error. * The original user object will be modified in-place with whatever values are applied successfully, and a copy will also passed into the promise. * * @returns {Promise} Promise that will resolve with the signature `resolver(updated_user)`, * where `updated_user` is the updated {@link User} object. or be rejected with * the signature `rejected(error_obj)`. * * @example * let me = await APISocket.login({ ...opts }) * me.mobile_number = \"555...\"; * me.avatar = \"http://gravatar.com/...\"; * me.language = \"es\"; * * me.save() * .then((me_updated) =&gt; console.log(me_updated)) * .catch((err) =&gt; console.error(err)); * */ async save() { let save_res; if (!this.id) return Logger.error(\"User.save must be run on a User object with an ID\"); // Only send the params this request that can be edited let request_options = _.pick(this, editable_fields); try { usr_save_res = await APISocket.patch(`user/${this.id}`, request_options); } catch (err) { } this.teams.map(async (team) =&gt; { try { save_res = await APISocket.patch(`team/${team.id}/users/${this.id}`, request_options); } catch (err) { } }) // Assign in passed values if (save_res) { for (let [key, value] of Object.entries(save_res)) { if (this.hasOwnProperty(key)) { this[key] = value; } else { // Logger.info(\"Key not found in User\", key, value); } } } return this; } /** * @summary * Deactivates a user by sending a DELETE request. Deactivated users * cannot be reached or log-in, and don't count as an active subscription. * Deactivated users can be reactivated at any time * * @ignore */ async deactivate() { // TODO // DELETE /user/:id // DELETE /team/:id/users/:uid } /** * @summary * Registers a device ID with a user's account, so that they can be * sent push notifications * * @ignore */ async registerDevice() { // TODO // POST /user/:id/devices } /** * @summary * Updates an existing device registration for push notifications * * @ignore */ async updateDeviceRegistration() { // TODO // PATCH /user/:id/devices/:registration_id } /** * @summary * Sends a push notification to a user's device * * @ignore */ async sendDeviceNotification() { // TODO // POST /user/:id/devices/notification } /** * @summary * Unregisters a device ID from a user's account, so push notifications * will no longer be sent to the device * * @ignore */ async unregisterDevice() { // TODO // DELETE /user/:id/devices/:registration_id } /** * @static * @summary * Loads a list of all users visible for the logged-in user. * * @param {Object} opts The options for the request * @param {Number} opts.limit The maximum number of users to return * @param {Number} opts.skip The number to start \"limit\" at */ static async getAll(opts) { let options = Object.assign({}, { limit: 1000, skip: 0, }, opts); let users = []; let users_raw; try { users_raw = await APISocket.get(`user?populate=teams,extension,role,plan&amp;limit=${options.limit}&amp;skip=${options.skip}`); } catch(err) { throw new Error('Cannot load user list', err); } users_raw.map((user_info) =&gt; { users.push(new User(user_info)); }); return users; } /** * @static * @summary * Loads a specific user. * * @param {Object} opts The options for the request * @param {String} opts.id The ID of the user to find * * @returns {User} The found user if one exists */ static async get(opts) { let user_info; let options = Object.assign({}, { id: false, }, opts); if (!options.id) Logger.error(\"User.get requires an id\"); try { user_info = await APISocket.get(`user/${options.id}?populate=teams,extension,role,plan`) } catch (err) { throw new Error('Cannot find user', err); } return new User(user_info); } /** * @summary * Admin-only: creates a user on a Team without inviting them, bypassing * email confirmation and setting the password manually * * @param {Object} opts Options for the user to be created * @param {String} opts.first_name First name of the user * @param {String} opts.last_name Last name of the user * @param {String} opts.email Email of the user. Used in authentication and cannot be modified after creation * @param {String} opts.password Password of the user * @param {Team|String} opts.team Either a Team object, or the ID of a team * * @returns {Promise} Promise that will be resolved with the new User object as the first argument, or rejected with the error as the first argument * * @example * User.create({ * first_name: \"Jane\", * last_name: \"Doe\", * email: \"user@example.com\", * password: \"hunter2\", * team: MyTeamObj * }) * .then((newUser) =&gt; console.log(\"Created user\", newUser.first_name, newUser.last_name)) * .catch((err) =&gt; console.error(\"Problem creating user\", err)) */ static async create(opts) { let options = Object.assign({}, { first_name: '', last_name: '', email: '', password: '', team: '' }, opts); if (!options.email) return Logger.error('User.create requires an email'); if (!options.first_name) return Logger.error('User.create requires a first name'); if (!options.last_name) return Logger.error('User.create requires a last name'); if (!options.password) return Logger.error('User.create requires a password'); if (!options.team) return Logger.error('User.create requires a Team object or a team ID'); // If user passed a Team object, pull the ID from that if (options.team.constructor.name == \"Team\") options.team = options.team.id const user = await APISocket.post(`team/${options.team}/add`, { first_name: options.first_name, last_name: options.last_name, email: options.email, password: options.password }); return new User(user); } /** * @summary * Admin-only: creates a user by sending them an email invite. * * @description * The email sent to the user and the resolver for this function will both contain an invite token, * which can be used by {@link User.acceptInvite `acceptInvite`} to complete the invitation process and * finish setting-up the user. * * @param {Object} opts Options for the request * @param {String} opts.email Email of the user to be invited * @param {Team|String} opts.team The team to look for this guest in. Either a Team object or a Team ID * * @returns {Promise} Promise that will resolve with an object representing a successful invite, or rejected with the error as the first argument. Successful invites will have the properties `email`, `user_id`, and `token` which is the email token needed for {@link User.acceptInvite `acceptInvite`}. * * @example * User.invite({ * email: \"newuser@example.com\", * team: myTeam * }) * .then((invite_result) =&gt; { * console.log(invite_result.email, invite_result.token, invite_result.user_id); * }) * .catch((err) =&gt; console.error(err)) * */ static async invite(opts) { let options = Object.assign({}, { email: '', team: '' }, opts); if (!options.email) throw Error('User.invite requires an email (opts.email)'); if (!options.team) throw Error('User.invite requires a Team object or a team ID (opts.team)'); if (typeof options.email != \"string\") throw TypeError(\"User.invite email must be a string, received\", typeof options.email) if (typeof options.team != \"string\" &amp;&amp; options.team.constructor.name != \"Team\") { throw TypeError(\"Guest.exists team must be either a team ID or a Team object, received\", typeof options.team); } // If user passed a Team object, pull the ID from that if (options.team.constructor.name == \"Team\") options.team = options.team.id; let user_exists; let user_res; // Check to see if the owner already exists try { user_exists = await User.exists(options.email); } catch (err) { throw Error(err); } if (user_exists) { throw Error(`User.invite can't use an existing email, ${options.email} is already in use`); } try { user_res = await APISocket.post(`team/${options.team}/invite`, Array({ email: options.email }) ); } catch (err) { throw Error(err); } return user_res[0]; } /** * @summary * Accepts an invite using the invite token either from the invitation email, or from {@link User.invite `invite`}. * * @description * Accepting also requires a user to assigning missing metadata like the user's name and password. * To send an invite, see {@link User.invite `invite`}. * * @param {Object} opts Options for the request * @param {String} opts.invite_token The invite token created by {@link User#invite `invite`} * @param {String} opts.first_name The first name of the user * @param {String} opts.last_name The last name of the user * @param {String} opts.password Password of the user * @param {Team|String} opts.team The team that this invite is for. Either a Team object or a Team ID * * @returns {Promise} Promise that will resolve with the registered user, or rejected with the error as the first argument * * @example * // Create the invite * User.invite({ * email: \"newuser@example.com\", * team: myTeam * }) * .then((invite_result) =&gt; { * * // Now accept the invite * User.acceptInvite({ * invite_token: invite_result.token, * first_name: \"Jane\", * last_name: \"Doe\", * password: \"hunter2\", * team: myTeam * }) * .then((invitedUser) =&gt; console.log(\"User accepted\", invitedUser); * .catch((err) =&gt; console.error(err)) * * }) * .catch((err) =&gt; console.error(err)) */ static async acceptInvite(opts) { let options = Object.assign({}, { invite_token: '', first_name: '', last_name: '', password: '', team: '' }, opts); // Check for required fields if (!options.invite_token) throw Error('Team.create requires an invite token (opts.invite_token)'); if (!options.first_name) throw Error('Team.create requires a first name (opts.first_name)'); if (!options.last_name) throw Error('Team.create requires a last name (opts.last_name)'); if (!options.password) throw Error('Team.create requires a password (opts.password)'); if (!options.team) throw Error('Team.create requires a Team object or a team ID (opts.team)'); if (typeof options.invite_token !== \"string\") throw TypeError(`User.acceptInvite invite_token must be a string, received ${typeof options.invite_token}`); if (typeof options.first_name !== \"string\") throw TypeError(`User.acceptInvite first_name must be a string, received ${typeof options.first_name}`); if (typeof options.last_name !== \"string\") throw TypeError(`User.acceptInvite last_name must be a string, received ${typeof options.last_name}`); if (typeof options.password !== \"string\") throw TypeError(`User.acceptInvite password must be a string, received ${typeof options.password}`); if (typeof options.team != \"string\" &amp;&amp; options.team.constructor.name != \"Team\") { throw TypeError(\"User.acceptInvite team must be either a team ID or a Team object, received\", typeof options.team); } // If user passed a Team object, pull the ID from that if (options.team.constructor.name == \"Team\") options.team = options.team.id let user_res; try { user_res = await APISocket.post(`team/${options.team}/accept`, { token: options.invite_token, first_name: options.first_name, last_name: options.last_name, password: options.password, }); } catch (err) { throw Error(err); } return new User(user_res); } /** * @summary * Check if a user exists, in order to create one safely. * * @param {String} email Email address to check the existence of * @returns {Promise} Promise that will resolve with a boolean representing if a user exists or not, or rejected with the error as the first argument * * @example * User.exists(\"existinguser@example.com\") * .then((userExists) =&gt; console.log(userExists ? 'user exists!' : 'no user with that email')) * .catch((err) =&gt; console.error(err)) */ static async exists(email = \"\") { let exists_res; let response_code; if (!email) Logger.error(\"User.exists requires an email address\"); if (typeof email !== \"string\") throw TypeError(`User.exists email must be a string, received ${typeof email}`); try { exists_res = await axios.post(`${APISocket.api_url}/v3/user/exist`, { email }); } catch(err) { return new Error(err); } response_code = parseInt(exists_res.status, 10); if (Math.floor(response_code / 100) === 2) { if ( typeof exists_res.data == \"object\" &amp;&amp; Object.prototype.hasOwnProperty.call(exists_res.data, 'exists') ) { return !!exists_res.data.exists; } } else { return false; } } } × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams Classes Classes APISocket Chat ChatMessage Guest Logger Team User A Skrumble Team Member. × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams Tutorials Classes APISocket Chat ChatMessage Guest Logger Team User A Skrumble Team Member. × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams @skrumble/js-sdk 0.1.5 InstallationThe JS SDK is distributed through the npm registry, which means it can be installed with npm. In a bash window, run: npm i --save @skrumble/js-sdk Or to install with yarn, run: yarn add @skrumble/js-sdkUsageThe SDK supports multiple formats for loading, depending on your environment: UMD var { Chat, APISocket } = require('@skrumble/js-sdk')ES6 import { Chat, APISocket } from '@skrumble/js-sdk'In case your environment doesn't support either, the SDK also exports a global called Skrumble, which contains the same classes as properties: let Chat = Skrumble.Chat let APISocket = Skrumble.APISocketConfiguring &amp; Logging-inFirst you'll need: Client credentials from the Skrumble Developer portal. See the Managing Applications guide for more about generating creds Hostnames for the environment you're using, see the Environment URLs guide for a reference import { Chat, APISocket } from '@skrumble/js-sdk'; let registeredUser, loadedChat APISocket.config({ client_id: \"iK47Sr....\", client_secret: \"$2y$10$J...\", api_hostname: \"sandbox.skrumble.com\", auth_hostname: \"sandbox-auth.skrumble.com\" }) try { registeredUser = await APISocket.login({ email: \"skrumble_user@example.com\", password: \"123456\" }) } catch(err) { throw new Error(err); } try { chatList = await Chat.getAll(); } catch(err) { throw new Error(err); } console.log(`Logged in as ${registeredUser.first_name}, found chat list of ${chatList}`); ContributingThe SDK is an open-source project, so Pull Requests and bug reports are encouraged. Before contributing, see the Github Issues page to ensure your issue/feature isn't a duplicate, and consult the CONTRIBUTING.md doc for information about contribution guidelines as well as the feature roadmap. × Search results Close "},"APISocket.html":{"id":"APISocket.html","title":"APISocket","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams APISocket Allows connection to the Skrumble API through a persistent socket connection. Many other classes like User, Chat, and Department rely on APISocket to make requests. APISocket.js, line 17 Properties api_url &lt;readonly&gt; String APISocket.js, line 65 auth_token &lt;readonly&gt; String The logged-in user's bearer token, this will automatically be appended to all future requests. APISocket.js, line 75 client_id &lt;readonly&gt; String The Client ID of the application. This is read-only, set using config APISocket.js, line 37 client_secret &lt;readonly&gt; String The Client Secret of the application. This is read-only, set using config APISocket.js, line 47 current_user &lt;readonly&gt; User After logging in and auth/refresh tokens are set properly, this will be the currently logged-in user for this socket connection. APISocket.js, line 97 hostname &lt;readonly&gt; String The hostname for future API reqeust, set using config APISocket.js, line 57 refresh_token &lt;readonly&gt; String The logged-in user's refresh token, this will automatically be used to refresh the APISocket#auth_token when the token has expired or requests begin failing with an HTTP code of 403 APISocket.js, line 86 socket Object The socket used to make requests. APISocket.js, line 27 Methods config(opts) &lt;async, static&gt; Configures the API socket for use, including the URLs and client tokens Parameters: Name Type Description opts Object Configuration options Properties Name Type Description client_id String Client ID of this application client_secret String Client secret of this application api_hostnae String Hostname for API requests, don't include protocol or port number auth_hostname String Hostname for Auth requests APISocket.js, line 551 connectSocket() &lt;async, static&gt; Initiates the socket connection. This connects a user to the socket and registers them for future changes. After the call to login completes, default behaviour will be to call this automatically. APISocket.js, line 323 delete(url, options) &lt;async, static&gt; Sends a DELETE request Parameters: Name Type Description url String Url to be passed to socket.io.get() options Object Options object to be passed to socket.io.get() APISocket.js, line 445 Returns: A promise object that either is resolved with success for sucessful (2xx) responses with the body of the response as the first argument. If the request fails (!= 2xx), the promise will be rejected with the body of the response as the first argument. Type Promise get(url, data) &lt;async, static&gt; Sends a GET request to the API socket. Parameters: Name Type Description url String Url to be passed to socket.io.get() data Object Data to be sent with the request APISocket.js, line 391 Returns: A promise object that either is resolved with success for sucessful (2xx) responses with the body of the response as the first argument. If the request fails (!= 2xx), the promise will be rejected with the body of the response as the first argument, and a JSON Websocket Response object as the second argument. Type Promise loadCurUser() &lt;async, static&gt; Load the current user based on their access token. Load the current user based on their access token APISocket.js, line 289 login(opts) &lt;async, static&gt; Authenticate a user and start listening for events over a persistent socket connection. Logs-in a user with the provided email and password. When the returned promise is resolved, it will return the authenticated user. Also connects user to the socket by default. See Logging-in for more Parameters: Name Type Description opts Object The options for this request Properties Name Type Argument Default Description email String Email address of the account to log-in password String Password of the account to log-in connect_socket Boolean &lt;optional&gt; true After a successful login, should the user's socket connection be initiated automatically. If this is disabled the socket connection must be created manually using connectSocket APISocket.js, line 134 Tutorials: Logging-in Example APISocket.login({ email: \"myuser@gmail.com\", password: \"123456\" }) .then((user) =&gt; { console.log(user, \"is now logged in!\"); }) .catch((err) =&gt; { console.error(\"Couldn't log-in!\", err); }) loginGuest(opts) &lt;async, static&gt; Authenticates a guest and start listening for events over a persistent socket connection. Logs-in a guest user, which are given access only to one group conversation. When the returned promise is resolved, it will return the authenticated guest user. Also connects to the socket by default. Parameters: Name Type Description opts Object The options for this request Properties Name Type Description first_name String The first name of the guest last_name String The last name of the guest email String The email address of the guest pin String The PIN of the chat the guest is joining. chat String The ID of the chat the guest is joining. team String The slug of the team that owns the chat the guest is joining. APISocket.js, line 217 logout() &lt;static&gt; Logs out the current user by forcefully closing the socket and resetting APISocket.current_user APISocket.js, line 370 off(evt, callback) &lt;static&gt; Unbinds a listener bound using APISocket.on Parameters: Name Type Description evt String The event type to unbind callback function Callback to unbind from this event APISocket.js, line 531 on(evt, callback) &lt;static&gt; Listens for socket messages coming into the API socket. The Skrumble API will emit the following types of events: Event Description chat This is the event about a chat, including new messages, changes to the participant list, or name user Event is about a user that has changed: state, status, *_name, avatar, etc teamuser Event is about a user that has changed: state, status, *_name, avatar, etc team Changes to the team information conference Changes to a group call's status Because this is a static method, the events above will fire for any activity of that type. For example, chat will be triggered on changes to all chats on the current team. To monitor an individual chat, use Chat.on Parameters: Name Type Description evt String The event type to listen for callback function Callback to fire when the event occurs APISocket.js, line 514 patch(url, options) &lt;async, static&gt; Sends a POST request Parameters: Name Type Description url String Url to be passed to socket.io.get() options Object Options object to be passed to socket.io.get() APISocket.js, line 427 Returns: A promise object that either is resolved with success for sucessful (2xx) responses with the body of the response as the first argument. If the request fails (!= 2xx), the promise will be rejected with the body of the response as the first argument. Type Promise post(url, options) &lt;async, static&gt; Sends a POST request Parameters: Name Type Description url String Url to be passed to socket.io.get() options Object Options object to be passed to socket.io.get() APISocket.js, line 409 Returns: A promise object that either is resolved with success for sucessful (2xx) responses with the body of the response as the first argument. If the request fails (!= 2xx), the promise will be rejected with the body of the response as the first argument. Type Promise request(method, url, options) &lt;async, static&gt; Sends a request with a given HTTP method. Shorthand versions are available as APISocket.get(), post(), patch(), and delete() Parameters: Name Type Description method String HTTP Method to be used in the request url String Url to be passed to socket.io.get() options Object Options object to be passed to socket.io.get() APISocket.js, line 465 Returns: A promise object that either is resolved with success for sucessful (2xx) responses with the body of the response as the first argument. If the request fails (!= 2xx), the promise will be rejected with the body of the response as the first argument. Type Promise × Search results Close "},"Chat.html":{"id":"Chat.html","title":"Chat","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams Chat A chat comes in two major types (see the type property): Private chats between exactly two users Group chats, which can contain a mixture of users and guests. Groups must contain at least one user, but have no upper-limit. Groups also have the property roomNumber and pin, which allows outside callers to call the chat directly. Chat.js, line 16 Properties avatar String The avatar for the chat. Only present on rooms Chat.js, line 124 created_at String ISO-8601 timestamp of when this chat was created. Chat.js, line 213 do_not_disturb Boolean Has this chat been set to silence notifications, from the perspective of the currently logged-in user. Chat.js, line 251 favourite Boolean Has this chat been marked as a favourite, from the perspective of the currently logged-in user. Chat.js, line 261 files Array.&lt;Object&gt; List of files sent in the chat. Chat.js, line 177 id String The ID of the chat. Chat.js, line 86 last_message_time String ISO-8601 timestamp of when this chat received it's last message Chat.js, line 241 last_seen String ISO-8601 timestamp of when this chat was last read, from the perspective of the currently logged-in user. Chat.js, line 232 links Array.&lt;Object&gt; List of URLs referenced in the messages of the chat. Chat.js, line 168 locked Boolean Locked groups will block guest access, and disconnect any guests. Unlocked groups allow guests to access the chat using the Chat#url property Chat.js, line 151 messages Array.&lt;ChatMessage&gt; The list of ChatMessages in this chat, in chronological order. Chat.js, line 195 name String The name of the chat. For private chats, this will be name of the other user. For a group chat, this will be a separate, unique name. Chat.js, line 105 pin Number PIN for calling to this chat via PSTN bridge, or for guest logins. Chat.js, line 159 purpose String The intended purpose of the chat. Only present on groups, this will be ignored for private chats Chat.js, line 115 roomNumber Number Room number for calling to this chat via PSTN bridge. Chat.js, line 132 team Team ID of the Team that this chat belongs to. Needed for the save() method. TODO: find a more elegant way to save this Chat.js, line 271 type String The type of the chat, options are private or group. Chat.js, line 95 unread Number Number of unread messages in this chat from the current user's perspective. Chat.js, line 141 updated_at String ISO-8601 timestmap of when this chat was last modified. Chat.js, line 222 url String The URL that guests can access this chat at. Only available on group chats. Chat.js, line 186 users Array.&lt;User&gt; The list of Users in this chat. Chat.js, line 204 Methods get(opts) &lt;async, static&gt; Gets a specific chat by ID. Loads chat messages by default, but for smaller responses this can be disabled with opts.load_messages = false Parameters: Name Type Description opts Object The options for this request Properties Name Type Argument Default Description id String The ID of the chat to load load_messages Boolean &lt;optional&gt; true true to load the chat message list, or false to disable message_limit Number &lt;optional&gt; 50 Maximum number of messages to load message_skip Number &lt;optional&gt; 0 Message number to start from Chat.js, line 443 getAll(opts) &lt;async, static&gt; Gets all chats that this user has access to, based on the pagination options limit, and skip Parameters: Name Type Description opts Object The options for this requiest Properties Name Type Argument Default Description limit Number &lt;optional&gt; 1000 Maximum number of chats to load skip Number &lt;optional&gt; 0 Chat number to start from Chat.js, line 406 addUser(users) &lt;async&gt; Adds user(s) to a chat Parameters: Name Type Description users Array.&lt;User&gt; The user(s) to add. Either supply a single User object, or an array of Users to add each. Chat.js, line 626 Returns: Successfully adding will return true Type Chat delete() &lt;async&gt; Deletes a chat Chat.js, line 806 Returns: Promise that will resolve with the server response as the first argument if the chat is deleted, or rejected with the error as the first argument Type Promise Example let myChat = await Chat.get({ id: \"abc123\" }); if (window.confirm('delete this chat?')) { myChat.delete() } generateGuestURL() &lt;async&gt; Enables guest access on this chat by generating a new PIN, and invalidate any existing guest sessions. Chat.js, line 520 inviteGuest(emails) &lt;async&gt; Invite guest(s) to join a group chat. Guests can only be added to chats with the type of group, can only access the chat they're added to, and will be removed if generateGuestURL is called again. Parameters: Name Type Description emails String | Array Either a single email address, or an array of email addresses to send guest invites to Chat.js, line 712 Returns: Promise that will be resolved with the result of the invite, or rejected with the error as the first argument. Type Promise Example Chat.get({ id: \"abc123\" }) .then((chat) =&gt; { // Send one invite chat.inviteGuest(\"myguest1@example.com\") // Send multiple invites chat.inviteGuest([\"myguest2@example.com\", \"myguest3@example.com\"]); }) markAsRead() &lt;async&gt; Marks a chat as read by updating the last_seen with the current time. This can be any chat that the user has access to. The original chat will be updated in-place with any successfully applied values, and a copy will also be passed into the promise. Chat.js, line 770 Returns: Promise that will resolve with the updated Chat as the first argument, or rejected with the error as the first argument Type Promise on(evt, callback) Listen for changes to this chat coming in over the APISocket. Event Description updated Chat information has changed. Callback will be called with the signature callback(evt, chat) with evt being the original socket event, and chat is the updated Chat object. This happens when a user changes the purpose, locked, or name. message New message to this chat, from someone else or from the current user. Callback will be called with the signature callback(evt, chat, message) with evt being the original socket event, chat is the Chat object with the new message inserted in messages, and message is the ChatMessage that was sent. Parameters: Name Type Description evt String The event to listen for callback function The callback to fire when the event occurs Chat.js, line 834 removeUser(users) &lt;async&gt; Remoevs user(s) from a chat Parameters: Name Type Description users Array.&lt;User&gt; The user(s) to remove. Either supply a single User object, or an array of Users to delete each. Chat.js, line 664 Returns: Successfully deleting will return true Type Chat save() &lt;async&gt; Saves a chat object by attempting to commit any dirty fields to the appropriate API endpoints. If the chat has an id and created_at date, then it will attempt to save the information. If those fields are unset, then the chat is assumed to be new and is created instead. Chat.js, line 488 sendFile(fileObj) &lt;async&gt; Sends a file Parameters: Name Type Description fileObj Object The file to send Chat.js, line 583 sendMessage(message) &lt;async&gt; Sends a chat message. Sends a text message to a chat, and then triggers the .on('message') listeners with the content of the new message. Parameters: Name Type Description message String The message to send Chat.js, line 546 toHTML() Converts a chat to an HTML fragment for debugging purposes. Chat.js, line 853 Example document.getElementById(\"chat_debug\").innerHTML = my_chat.toHTML(); × Search results Close "},"ChatMessage.html":{"id":"ChatMessage.html","title":"ChatMessage","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams ChatMessage ChatMessages describe individual messages inside a Chat. This can be simple messages like text or files, or events like a user joining a group. For more information about the various types of ChatMessages and how to handle them, see type. ChatMessage.js, line 15 Properties body String The content of the message. ChatMessage.js, line 49 chat String The ID of the Chat this belongs to ChatMessage.js, line 80 created_at String The ISO 8601 string representing the time this message was created on the server ChatMessage.js, line 89 file Object Files attached to this message, or false. For messages with a type of file, recording_video, or voicemail, this will be the information about the file. Messages of other types will have this set to false. Property Description url Public URL to download this file created_at ISO 8601 string of the time the file was created name Full uploaded path and filename size Filesize in bytes filename Filename only thumb_url Thumbnail URL, for png, jpg, and gif files only thumbHeight Height in px of the thumbnail thumbWidth Width in px of the thumbnail ChatMessage.js, line 72 from User|Guest Who this message was sent by. ChatMessage.js, line 97 id String The unique ID of this message. ChatMessage.js, line 105 language String The language this message was sent in. ChatMessage.js, line 113 links Array.&lt;String&gt; An array of URLs in this message. ChatMessage.js, line 121 room_mentions Array An array of mentions to chats in this message. ChatMessage.js, line 129 type String The type of event this message is for. ChatMessages don't just represent traditional text messages or files, but also several different types of notifications about the chat itself. Options are: Type Description text This is a text chat message, with the content in body. file A file message with the properties of the file on the file property. call_log A record of a call with this chat. Call logs for groups will have the body.type of conference_started (starting a call), conference_ended (call ended), conference_join (user joining call), or conference_leave (user leaving call). Private chats will have the body.type of missed or call (which will have body.duration with the duration of the call in seconds). voicemail A voicemail left by another user in a private chat. The file field will be a wav file of the message chat_renamed Group chat only. The name of this chat was changed. The body will be an object: { 'new': 'group new name', 'old': 'group previous name' } chat_purpose Group chat only. The purpose of this chat was changed. The body will be an object: { 'new': 'group new purpose', 'old': 'group prev purpose' } chat_locked Group chat only. A user has locked/unlocked a group. The body will be 1 if the group was locked, and 0 if it was unlocked participant_added Group chat only. User(s) have been added to the chat. The body will be an array of users that have been added. participant_removed Group chat only. User(s) have been removed from the chat. The body will be an array of users that have been removed. recording_video The recording of a group conference, along with an optional transcript. The attached file is the recording. ChatMessage.js, line 41 user_mentions Array An array of mentions to users in this message ChatMessage.js, line 137 Methods toHTML() Converts a chat to an HTML fragment for debugging purposes. ChatMessage.js, line 214 Example document.getElementById(\"chat_msg_debug\") = chat_message.toHTML(); translate() &lt;async&gt; Translates a message and returns the translation. Languages for the translation are automatic and based on the language property of the user sending the message, and the user performing the translation. For example, if a user with the language of es sends a message, and the current user has a language of fr, then this will attempt to translate from Spanish to French. This will only work on messages with the type of text ChatMessage.js, line 188 See: User.language Returns: Promise that will resolve with the translation as the first argument Type Promise Example ChatMessage.translate() .then((translation) =&gt; { console.log(translation); }) × Search results Close "},"Guest.html":{"id":"Guest.html","title":"Guest","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams Guest Guests are temporary users that are granted access to one group Chat using the chat's guest URL. Guest.js, line 12 Properties avatar String The URL of the guest's avatar. Guest.js, line 52 caller_id_name String When making outbound calls, this will be the name field of the Caller ID, visible to the other caller. If this is blank (default), the name will default to Team.caller_id_name. Guest.js, line 109 caller_id_number String When making outbound calls, this will be the number field of the Caller ID, visible to the other caller. If this is blank (default), the name will default to Team.caller_id_number. Guest.js, line 118 chat_id String The Chat ID this guest is valid for. Guest.js, line 70 email String The email address of the guest. Guest.js, line 61 first_name String The first name of the guest. Guest.js, line 34 id &lt;readonly&gt; String The ID of the user, assigned by the API Guest.js, line 25 last_name String The last name of the guest. Guest.js, line 43 role String The user's role on the team, possibilities are admin or member Guest.js, line 88 teams &lt;readonly&gt; Array.&lt;Team&gt; A list of teams this user is on Guest.js, line 99 Methods exists(opts) &lt;async, static&gt; Check if a guest exists on a given team. Guests are unique to each team, so a Team or TeamID must also be supplied, and can only be called after logging-in. This is called automatically by Chat.inviteGuest(). Parameters: Name Type Description opts Object Options for this request Properties Name Type Description email String Email of the guest to look for team Team | String The team to look for this guest in. Either a Team object or a Team ID Guest.js, line 153 Returns: Promise that will resolve with a boolean representing if a team with that name exists or not, or rejected with the error as the first argument Type Promise Example Guest.exists({ email: \"guestuser@example.com\", team: myTeam }) .then((guestExists) =&gt; console.log(guestExists ? 'guest exists!' : 'no guest with that email')) .catch((err) =&gt; console.error(err)) × Search results Close "},"Logger.html":{"id":"Logger.html","title":"Logger","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams Logger Logger.js, line 17 Methods error() &lt;static&gt; Print something to the console as an error Logger.js, line 57 info() &lt;static&gt; Print something to the console as an info message Logger.js, line 35 log() &lt;static&gt; Print something to the console as a message Logger.js, line 24 setLogLevel() &lt;static&gt; Sets the logging level Logger.js, line 68 warn() &lt;static&gt; Print something to the console as a warning Logger.js, line 46 × Search results Close "},"Team.html":{"id":"Team.html","title":"Team","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams Team The settings and info for a team. Team.js, line 33 Properties address_1 String Team's address line 1 Team.js, line 116 address_2 String Team's address line 2 Team.js, line 125 autoreception String What point of setting-up autoreception is complete. Options are completed @todo Team.js, line 151 caller_id_name String The default caller ID name field for all members. Team.js, line 162 See: User#caller_id_name caller_id_number String The default caller ID number field for all members. Team.js, line 173 See: User#caller_id_number city String Team's city. Team.js, line 98 country String Team's country. Team.js, line 89 id String Unique ID of the team. Team.js, line 44 owner User The User that created this team. Team.js, line 53 postal String Team's postal or zip code Team.js, line 134 slug String Team name with special characters removed. Used to create URL-friendly guest links. Team.js, line 80 state String Team's province or state Team.js, line 107 team_avatar String The URL of the team's avatar. Team.js, line 71 team_name String Display name of the team. Team.js, line 62 timezone String The TZ string of this team's timezone Team.js, line 143 Methods create(opts) &lt;async, static&gt; Creates a team Creates a team by first creating an Owner account, who is the first user on the team. Then creates the team and assigns the Owner to it. NB: Team names are unique Parameters: Name Type Description opts Object Options for the request Properties Name Type Argument Description owner_first_name String Owner's first name owner_last_name String Owner's last name owner_email String Owner's email. Used later for authentication and cannot be changed. owner_password String Owner's password name String Name of the team country String Team country city String Team city state String Team state referral_code String &lt;optional&gt; Referral code, if any Team.js, line 250 Returns: Promise that will resolve with the newly created team if the team creation was successful, and be rejected with an error as the first argument if the attempt fails Type Promise Example let owner_email = \"owner@example.com\"; let owner_password = \"hunter2\"; Team.create({ owner_first_name: \"jane\", owner_last_name: \"doe\", owner_email, owner_password, name: \"My SDK Team\", country: \"Canada\", city: \"Toronto\", state: \"ON\" }) .then((newTeam) =&gt; { console.log(\"new team created\", newTeam); // You can log-in now as the owner APISocket.login({ email: owner_email, password: owner_password }) }) .catch((err) =&gt; console.error(\"team creation err\", err)) exists(team_name) &lt;async, static&gt; Check if a team exists, in order to create one safely. This is called automatically during Team.create() Parameters: Name Type Description team_name String Team name to check the existence of Team.js, line 410 Returns: Promise that will resolve with a boolean representing if a team with that name exists or not, or rejected with the error as the first argument Type Promise Example Team.exists(\"My team name\") .then((teamExists) =&gt; console.log(teamExists ? 'team exists!' : 'no team with that name')) .catch((err) =&gt; console.error(err)) get(opts) &lt;async, static&gt; Loads a team by ID. Loads a team by ID Parameters: Name Type Description opts Object Options for the request Properties Name Type Description id String The ID of the team to load Team.js, line 192 save() &lt;async&gt; Admin-only: save any changed information about a Team. The original team object will be modified in-place with whatever values are applied successfully, and a copy will be passed into the promise. Team.js, line 370 Returns: Promise that will resolve with the updated Team as the first argument, or rejected with the error as the first argument Type Promise Example let me = await APISocket.login({ ...opts }) let myTeam = me.teams[0]; myTeam.team_name = \"New team name\"; myTeam.city = \"Toronto\"; myTeam.save() .then((myTeam) =&gt; console.log(\"Updated myTeam\", myTeam)) .catch((err) =&gt; console.error(\"Team save error\", err)) × Search results Close "},"User.html":{"id":"User.html","title":"User","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams User The User class allows read access to user information. It's also possible to update User information with save() if the User you're editing is yourself, or if you're logged-in as an Admin. Static methods like get() or create() won't work on User instances, but will retrieve or create User objects respectively. Users will emit socket events when information about them is modified User.js, line 68 See: User.create User.invite Example var workingUser = User.create({ email: \"user@example.com\", // Required plan: \"pro\", // Required first_name: \"Test\", // Required, minlength: 2 last_name: \"User\", // Required, minlength: 2 password: \"Password1\", // Required, minlength: 8 team: \"abc123\" // Required }) // Persist changes workingUser.position = \"CEO\"; workingUser.save(); Properties accepted String The ISO8601 datestamp of when the user accepted the invitation to join the team. If the user was created and not invited, then this will be equal to the user's created_at. User.js, line 369 avatar String URL to the user's avatar User.js, line 126 caller_id_name String When making outbound calls, this will be the name field of the Caller ID, visible to the other caller. If this is blank (default), the name will default to Team.caller_id_name. User.js, line 288 caller_id_number String When making outbound calls, this will be the number field of the Caller ID, visible to the other caller. If this is blank (default), the name will default to Team.caller_id_number. User.js, line 297 created_at &lt;readonly&gt; String The datetime a user was created in ISO 8601 User.js, line 222 dateformat String The formatting of dates User.js, line 203 deleted_at String The ISO8601 datestamp of when this user was deactivated. Deactivated users cannot send or recieve chat messages or calls, and won't appear in chat participant lists or lists of users User.js, line 387 email String Email address. User.js, line 110 extension Array.&lt;String&gt; User.js, line 231 first_name String The first name of the user User.js, line 86 forward Boolean The user's call forwarding setting. true will forward all inbound calls to User.forward_number and false will recieve calls normally User.js, line 269 forward_number Dialstring If User.forward is enabled, this will set where inbound calls are directed to User.js, line 278 home_number Dialstring The home number the user has entered in their profile. User.js, line 315 id &lt;readonly&gt; String The ID of the user, assigned by the API User.js, line 78 language String The user's preferred language. Used for comparison when calling ChatMessage.translate. Also used by official Skrumble clients to determine interface language. User.js, line 176 See: List of ISO-639-1 codes - Wikipedia last_login String The ISO8601 datestamp of when this user last logged-in User.js, line 378 last_name String The last name of the user User.js, line 94 latitude String The user's last recorded latitude. User.js, line 342 longitude String The user's last recorded longitude User.js, line 351 mobile_number Dialstring The mobile number the user has entered in their profile. User.js, line 324 password String User password in plain text. User.js, line 118 plan String The user's subscription type, either the Pro or Unlimited packages currently User.js, line 161 position String Position in the team User.js, line 102 role String The user's role on the team, possibilities are admin or member User.js, line 152 state String The state of the user, the options are online or offline User.js, line 135 status String The call availability of this user User.js, line 143 teams &lt;readonly&gt; Array.&lt;Team&gt; A list of teams this user is on User.js, line 250 theme String The user's preferrerd desktop theme, the options are dark and light. New users wll default to dark. User.js, line 360 timeformat String The user's preferred formatting of time values: 12-hour or 24-hour User.js, line 194 timezone String The TZ string value of the user's timezone User.js, line 185 tooltips Boolean true if the user has requested UI tooltips for help on app.skrumble.com, false if disabled. User.js, line 212 voicemail boolean Is voicemail enabled for this user or not. If true, then calls that go unanswered after 30s will be redirected to the user's voicemail box. false will disable voicemail entirely and missed calls will simply end. User.js, line 260 website String The website the user has entered in their profile. This should be a valid URL. User.js, line 333 work_number Dialstring The work number the user has entered in their profile. User.js, line 306 Methods acceptInvite(opts) &lt;async, static&gt; Accepts an invite using the invite token either from the invitation email, or from invite. Accepting also requires a user to assigning missing metadata like the user's name and password. To send an invite, see invite. Parameters: Name Type Description opts Object Options for the request Properties Name Type Description invite_token String The invite token created by invite first_name String The first name of the user last_name String The last name of the user password String Password of the user team Team | String The team that this invite is for. Either a Team object or a Team ID User.js, line 758 Returns: Promise that will resolve with the registered user, or rejected with the error as the first argument Type Promise Example // Create the invite User.invite({ email: \"newuser@example.com\", team: myTeam }) .then((invite_result) =&gt; { // Now accept the invite User.acceptInvite({ invite_token: invite_result.token, first_name: \"Jane\", last_name: \"Doe\", password: \"hunter2\", team: myTeam }) .then((invitedUser) =&gt; console.log(\"User accepted\", invitedUser); .catch((err) =&gt; console.error(err)) }) .catch((err) =&gt; console.error(err)) create(opts) &lt;async, static&gt; Admin-only: creates a user on a Team without inviting them, bypassing email confirmation and setting the password manually Parameters: Name Type Description opts Object Options for the user to be created Properties Name Type Description first_name String First name of the user last_name String Last name of the user email String Email of the user. Used in authentication and cannot be modified after creation password String Password of the user team Team | String Either a Team object, or the ID of a team User.js, line 620 Returns: Promise that will be resolved with the new User object as the first argument, or rejected with the error as the first argument Type Promise Example User.create({ first_name: \"Jane\", last_name: \"Doe\", email: \"user@example.com\", password: \"hunter2\", team: MyTeamObj }) .then((newUser) =&gt; console.log(\"Created user\", newUser.first_name, newUser.last_name)) .catch((err) =&gt; console.error(\"Problem creating user\", err)) exists(email) &lt;async, static&gt; Check if a user exists, in order to create one safely. Parameters: Name Type Description email String Email address to check the existence of User.js, line 815 Returns: Promise that will resolve with a boolean representing if a user exists or not, or rejected with the error as the first argument Type Promise Example User.exists(\"existinguser@example.com\") .then((userExists) =&gt; console.log(userExists ? 'user exists!' : 'no user with that email')) .catch((err) =&gt; console.error(err)) get(opts) &lt;async, static&gt; Loads a specific user. Parameters: Name Type Description opts Object The options for the request Properties Name Type Description id String The ID of the user to find User.js, line 576 Returns: The found user if one exists Type User getAll(opts) &lt;async, static&gt; Loads a list of all users visible for the logged-in user. Parameters: Name Type Description opts Object The options for the request Properties Name Type Description limit Number The maximum number of users to return skip Number The number to start \"limit\" at User.js, line 541 invite(opts) &lt;async, static&gt; Admin-only: creates a user by sending them an email invite. The email sent to the user and the resolver for this function will both contain an invite token, which can be used by acceptInvite to complete the invitation process and finish setting-up the user. Parameters: Name Type Description opts Object Options for the request Properties Name Type Description email String Email of the user to be invited team Team | String The team to look for this guest in. Either a Team object or a Team ID User.js, line 677 Returns: Promise that will resolve with an object representing a successful invite, or rejected with the error as the first argument. Successful invites will have the properties email, user_id, and token which is the email token needed for acceptInvite. Type Promise Example User.invite({ email: \"newuser@example.com\", team: myTeam }) .then((invite_result) =&gt; { console.log(invite_result.email, invite_result.token, invite_result.user_id); }) .catch((err) =&gt; console.error(err)) save() &lt;async&gt; Saves the details of a given user by sending a PATCH request. For admins, this can be the information of any team member. For regular users, it can only be their own information, or the API will return an error. The original user object will be modified in-place with whatever values are applied successfully, and a copy will also passed into the promise. User.js, line 428 Returns: Promise that will resolve with the signature resolver(updated_user), where updated_user is the updated User object. or be rejected with the signature rejected(error_obj). Type Promise Example let me = await APISocket.login({ ...opts }) me.mobile_number = \"555...\"; me.avatar = \"http://gravatar.com/...\"; me.language = \"es\"; me.save() .then((me_updated) =&gt; console.log(me_updated)) .catch((err) =&gt; console.error(err)); × Search results Close "},"tutorial-chats.html":{"id":"tutorial-chats.html","title":"Tutorial: Chats","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams Chats Skrumble Chats are exposed through the Chat class, which has a number of static methods to find or create chats. Chats can either be between two users, called Private Chats, or with 1 or more users, called Group Chats. Note: These tutorials assume that you already have a user that is logged-in to the socket. Where necessary, we'll refer to them as myUser. Finding chatsChats can either be loaded individually by ID with Chat.get(), or a list of all chats can be loaded with Chat.getAll(). import { Chat } from '@skrumble/js-sdk'; // Load the first 100 chats visible to this user var allChats = await Chat.getAll({ limit: 100, skip: 0 }) // allChats now has a list of every chat, so we can do things like ... allChats.map((chat) =&gt; { // logging info... if (chat.type == \"private\") { console.log(`Private chat loaded! Message count: ${chat.messages.length}`); } else if (chat.type == \"group\") { console.log(`Group ${chat.name} loaded! Message count: ${chat.messages.length}`); } // ... or listening for events/messages // see below for handling these events chat.on('message', incomingMessageHandler); chat.on('updated', chatUpdatedHandler); }) // Or load an individual chat, if you know the ID.... var myChat = await Chat.get({ id: \"abc123..\", message_limit: 1000, message_skip: 0 }) // ... and it returns a single Chat object console.log(myChat.name);Creating chatsCreating and updating chats both use the Chat.save() method. If a Chat object has the properties id and created_at set, then the SDK assumes that the chat already exists and attempts to update it using the ID. If either of those fields are unset, then the SDK will assume that it's a new chat, and will attempt to create it instead. import { Chat } from '@skrumble/js-sdk'; // To create a group, specify `type: room`, and `users` is a list of // TeamUserIDs of who should be added. The user creating the group is always // added as a participant let myNewGroupChat = await new Chat({ name: \"My awesome group\", purpose: \"Let's discuss awesome stuff\", type: \"room\", team: myUser.teams[0].id, // This is your logged-in user users: ['abc123...', 'xyz456...'] }).save(); // Now we can listen for messages myNewGroupChat.on('message', incomingMessageHandler); myNewGroupChat.on('updated', chatUpdatedHandler); // Or to create a private chat, specify `type: private` and the // list of users should just be the other user. Private chats // don't have a name or purpose. let myNewPrivateChat = await new Chat({ type: \"private\", team: myUser.teams[0].id, // This is your logged-in user users: ['abc123...', 'xyz456...'] }).save();Chat MessagesOnce a chat instance has been loaded, messages can be sent and recieved using Chat.on('message') and Chat.sendMessage() methods. We'll use the myNewGroupChat example from above, but this can be any instance of a Chat. // Listen for new incoming message. `evt` is the raw socket event, // `message` is the new ChatMessage instance, and `chat` is the Chat instance. myNewGroupChat.on('message', (evt, message, chat) =&gt; { // The `type` of message will tell us if it's either a // file, text, or an in-chat event log switch (message.type) { case 'text': // Outputs: New message in mygroupname: Hello world! console.log(`New message in ${chat.name}: ${message.body}`); break; case 'file': // Outputs: New file in mygroupname: filename.jpg (100kb) console.log(`New file in ${chat.name}: ${message.file.name} (${message.file.size})`); break; // Messages are sent to the chat announcing things like // users entering/leaving, starting or stopping a group call, // or renaming the chat. Private chats will also log voicemails from the other user case 'call_log': case 'voicemail': case 'chat_renamed': case 'chat_purpose': case 'chat_locked': case 'participant_added': case 'particpant_removed': case 'recording_video': console.log(`New event log in ${chat.name}: ${message.type}, ${JSON.stringify(message.body)}`); break; } });Sending a text message simply requires the chat instance, and the text to be sent. Similar to chat creation, sendMessage returns a promise that's resolved with the ChatMessage instance once the API has successfully sent the message. Successful outbound messages will also trigger Chat.on('message'), so user interfaces can respond to outbound messages as well. If the message fails to send, the promise will be rejected with any applicable error. myNewGroupChat.on('message', (evt, message, chat) =&gt; { if (message.from == myUser) console.log(\"Message from myself\", message) // Inbound and outbound messages can use this same callback to update the UI document.getElementById(\"chatMessageList\").innerHTML = chat.toHTML(); }); // Send the message... try { let mySentMessage = await myNewGroupChat.sendMessage(\"Hello world!\") } catch (err) { console.error(\"Message failed to send:\", err); }EmojiThere are two ways to send emoji inside of chat messages. The unicode glyph (eg, 🎱) can be used, or the shortcode version from EmojiOne (eg :confused:) can be used. Messages can even use a combination of both: let emojiMsg = await myChat.sendMessage('hello 👋 :thumbs_up:')The official Skrumble clients will replace shortcodes with the proper emoji glyphs (eg, :thumbs_up: into 👍), and any unicode glyphs will be rendered in the local character set. MentionsWhen sending messages with the type of text, the body can contain mentions of other users or groups. When a user is mentioned, they'll recieve an additional notification that someone has mentioned them in a chat. Users will only receive notifications if the mention happens in a group they have access to. Group mentions simply act as links to other groups. On the official skrumble desktop client, both types of mentions will be parsed into links that can be hovered-over for more information. Messages can contain as many mentions as desired, and will work in both private and group chats. The format for mentions is similar to XML. To mention a user, specify their TeamUserID as the user attribute, and their name as the content of the node. Or to mention a group, specify the Chat ID as the room attribute, and the group name as the content of the node: &lt;mention user=\"abc123...\"&gt;Lauren Ipsum&lt;/mention&gt; &lt;mention room=\"123abc...\"&gt;My Group Name&lt;/mention&gt;Note that only one mention per tag is allowed, but a message can contain an unlimited number of mentions. When sending, simply add the &lt;mention&gt; tag to the body of your message: let userMentionMsg = await myChat.sendMessage(`Hey, &lt;mention user=\"abc123...\"&gt;Lauren Ipsum&lt;/mention&gt; how's it going!`)This can be made even easier if you already have the User object that you're trying to mention: let user = await User.get({ id: \"abc123...\" }); let userMentionMsg = await myChat.sendMessage(`Hey, &lt;mention user=\"${user.id}\"&gt;${user.first_name} ${user.last_name}&lt;/mention&gt; how's it going!`);When receiving a message containing mentions, the ChatMessage properties room_mentions and user_mentions will respectively have an array of group or user objects, however: myNewGroupChat.on('message', (evt, message, chat) =&gt; { // This message contains user mentions if (message.user_mentions.length &gt; 0) { // Log all the mentioned users message.user_mentions.map((mentioned_user) =&gt; { console.log(`Mentioned user: ${mentioned_user.first_name} ${mentioned_user.last_name} (${mentioned_user.id})`) }); } // This message contains room mentions if (message.room_mentions.length &gt; 0) { // Log all the mentioned groups message.room_mentions.map((mentioned_group) =&gt; { console.log(`Mentioned group: ${mentioned_group.name} - ${mentioned_group.purpose} (${mentioned_group.id})`) }); } });TranslationsAny message with the type of text can be translated into the language of choice for the current user. Languages for the translation are automatic and based on the language property of the user sending the message, and the user performing the translation. For example, if a user with the language of es sends a message, and the current user has a language of fr, then this will attempt to translate from Spanish to French. // Listen for new incoming message. `evt` is the raw socket event, // `message` is the new ChatMessage instance, and `chat` is the Chat instance. myNewGroupChat.on('message', async (evt, message, chat) =&gt; { if (message.from.language != \"en\") { // This is from a non-english speaking user let en_translation = await message.translate(); console.log(`New message translated: ${en_translation}`) } }); × Search results Close "},"tutorial-logging-in.html":{"id":"tutorial-logging-in.html","title":"Tutorial: Logging-in","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams Logging-in In order to authenticate, all applications need a set of Client Credentials, which identify an app to the API. Each set of credentials is specific to the server environment they were created for, meaning Sandbox credentials won't work on Production and vice-versa. See the Authentication and Managing Applications guides on the Skrumble for Developers website. Once your credentials are created, the first step is to import the SDK and configure the APISocket to use use your client creds, along with URLs for the server. For this tutorial we'll use the Sandbox to avoid costs. import { APISocket } from '@skrumble/js-sdk'; let registeredUser, loadedChat APISocket.config({ client_id: \"iK47Sr....\", client_secret: \"$2y$10$J...\", api_hostname: \"sandbox.skrumble.com\", auth_hostname: \"sandbox-auth.skrumble.com\" })Now that the socket is configured with the correct hostnames and credentials, users can start to log-in to any existing team on the Communication API. To create a new team, see the Managing Teams tutorial. Most of the JS-SDK is written with promises, which means that you can either log-in with the traditonal .then()/.catch() syntax, or async/await if your application is using ES2017: // either ES6-style with promises ... myUser = APISocket.login({ email: \"skrumble_user@example.com\", password: \"123456\" }).then((myUser) =&gt; { console.log(myUser, 'now logged in!'); }).catch((error) =&gt; { throw new Error(err); }); // ... or ES2017 using async/await try { let myUser = await APISocket.login({ email: \"skrumble_user@example.com\", password: \"123456\" }) console.log(myUser, 'now logged in!'); } catch(err) { throw new Error(err); }The result for either example is that myUser will be a fully authenticated user, meaning that they should have an access token and refresh token. Incorrect username/password combinations will be rejected by the server, and in these examples will throw an Error. Both tokens are automatically decorated on the APISocket, as is the user who has connected: // After login... console.log(APISocket.access_token); // abc123... console.log(APISocket.refresh_token); // xyz123... console.log(APISocket.current_user); // User object Now it will be possible to start using chats, inviting guests, or adding new users. × Search results Close "},"tutorial-managing-teams.html":{"id":"tutorial-managing-teams.html","title":"Tutorial: Managing Teams","body":" Skrumble JS SDK Classes APISocketChatChatMessageGuestLoggerTeamUser Tutorials ChatsLogging-inManaging Teams Managing Teams Most of the functionality for managing a Team on the Communication API is handled through the Team class. Creating TeamsCreating a team can be done with the Team.create() method, which will create both the team owner and the team itself. Since both user emails and team names are unique, the SDK will throw an exception if either is already taken. import { APISocket, Team } from '@skrumble/js-sdk'; // Configure the socket APISocket.config({ client_id: \"iK47Sr....\", client_secret: \"$2y$10$J...\", api_hostname: \"sandbox.skrumble.com\", auth_hostname: \"sandbox-auth.skrumble.com\" }) // Create the team try { let myTeam = await Team.create({ owner_first_name: \"Lorem\", owner_last_name: \"Ipsum\", owner_email: \"first_user@example.com\", owner_password: \"hunter2\", name: \"Lorem Co\", country: \"Canada\", city: \"Toronto\", state: \"ON\" }); } catch (err) { // Team.create promise will be rejected with exceptions for // emails/team names being taken, missing fields, or if the API fails // to return a 201 Created (network interruption, server error, etc) console.error(`Error creating team: ${err.message}`); }Inviting users// Create the invite User.invite({ email: \"newuser@example.com\", team: myTeam }) .then((invite_result) =&gt; { // Now accept the invite User.acceptInvite({ invite_token: invite_result.token, first_name: \"Jane\", last_name: \"Doe\", password: \"hunter2\", team: myTeam }) .then((invitedUser) =&gt; console.log(\"User accepted\", invitedUser); .catch((err) =&gt; console.error(err)) }) .catch((err) =&gt; console.error(err))Adding usersUser.create({ first_name: \"Jane\", last_name: \"Doe\", email: \"user@example.com\", password: \"hunter2\", team: MyTeamObj }) .then((newUser) =&gt; console.log(\"Created user\", newUser.first_name, newUser.last_name)) .catch((err) =&gt; console.error(\"Problem creating user\", err))Updating usersUsers are able to update their own information, such as their name, position, preferred language, and other properties visible on the User object. let me = await APISocket.login({ ...opts }) me.mobile_number = \"555...\"; me.avatar = \"http://gravatar.com/...\"; me.language = \"es\"; me.save() .then((me_updated) =&gt; console.log(me_updated)) .catch((err) =&gt; console.error(err));In addition, all Admins on the team are allowed to modify the information of other users. For instance, an Admin would be able to loop through all the users on the team and set their work phone number: let user_list = await User.getAll(); user_list.forEach((user) =&gt; { user.work_number = \"123-555-1234\"; try { user.save(); } catch (err) { console.error(`Error updating user phone #: ${err.message}`); } }) × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
